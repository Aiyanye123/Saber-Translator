**3.1. 更新后端翻译 API (`src/app/api/translate_api.py`)**

*   **文件路径:** `src/app/api/translate_api.py`
*   **修改内容:**
    *   在 `/translate_image` 路由函数的开头，从 `request.get_json()` 获取 `custom_ai_vision_base_url`。
    *   在参数检查部分，添加一个条件：如果 `ocr_engine` 是 `constants.AI_VISION_OCR_ENGINE_ID` 并且 `ai_vision_provider` 是 `constants.CUSTOM_AI_VISION_PROVIDER_ID`，但 `custom_ai_vision_base_url` 未提供或为空，则返回一个 400 错误。
    *   在调用 `process_image_translation` 时，将 `custom_ai_vision_base_url` 作为新参数传递。

*   **代码演示:**

    ```python
    # src/app/api/translate_api.py
    
    from flask import Blueprint, request, jsonify # 已有
    # ... (其他 import)
    from src.core.processing import process_image_translation
    from src.shared import constants # 确保导入常量
    
    translate_bp = Blueprint('translate_api', __name__, url_prefix='/api')
    logger = logging.getLogger("TranslateAPI")
    
    # ... (其他路由，如 re_render_image 等) ...
    
    @translate_bp.route('/translate_image', methods=['POST'])
    def translate_image():
        """处理图像翻译请求"""
        try:
            data = request.get_json()
    
            # ... (获取所有已有的参数：image_data, target_language, ..., ocr_engine, baidu_api_key, etc.) ...
    
            # VVVVVV 新增：获取 AI 视觉 OCR 相关参数，包括自定义 Base URL VVVVVV
            ai_vision_provider = data.get('ai_vision_provider')
            ai_vision_api_key = data.get('ai_vision_api_key')
            ai_vision_model_name = data.get('ai_vision_model_name')
            ai_vision_ocr_prompt = data.get('ai_vision_ocr_prompt', constants.DEFAULT_AI_VISION_OCR_PROMPT)
            custom_ai_vision_base_url = data.get('custom_ai_vision_base_url') # <<< 获取新的参数
            # ^^^^^^ 结束新增 ^^^^^^
    
            ocr_engine = data.get('ocr_engine', 'auto') # 确保 ocr_engine 已获取
    
            # ... (已有的参数检查逻辑，例如检查 image_data, target_language 等) ...
    
            # VVVVVV 新增参数检查：如果使用自定义AI视觉OCR，必须提供Base URL VVVVVV
            if ocr_engine == constants.AI_VISION_OCR_ENGINE_ID and \
               ai_vision_provider == constants.CUSTOM_AI_VISION_PROVIDER_ID and \
               not custom_ai_vision_base_url:
                logger.error("请求错误：使用自定义AI视觉OCR服务时缺少 custom_ai_vision_base_url")
                return jsonify({'error': '使用自定义AI视觉OCR服务时必须提供Base URL (custom_ai_vision_base_url)'}), 400
            # ^^^^^^ 结束新增参数检查 ^^^^^^
    
            # ... (已有的其他参数检查，如百度OCR的key检查) ...
    
            # 调用核心处理函数，传递所有参数
            translated_image, original_texts, bubble_texts, textbox_texts, bubble_coords, bubble_styles = process_image_translation(
                image_pil=img, # 假设 img 已经从 image_data 解码得到
                target_language=target_language,
                source_language=source_language,
                font_size_setting=font_size, # 假设 font_size 已处理
                font_family_rel=corrected_font_path, # 假设 corrected_font_path 已处理
                text_direction=text_direction,
                model_provider=model_provider,
                api_key=api_key,
                model_name=model_name,
                prompt_content=prompt_content,
                use_textbox_prompt=use_textbox_prompt,
                textbox_prompt_content=textbox_prompt_content,
                inpainting_method=inpainting_method, # 假设 inpainting_method 已确定
                fill_color=fill_color,
                migan_strength=inpainting_strength, # 假设 inpainting_strength 已处理
                migan_blend_edges=blend_edges,
                skip_ocr=skip_ocr,
                skip_translation=True if remove_only or skip_translation else False, # 调整 skip_translation 逻辑
                provided_coords=provided_coords,
                text_color=text_color,
                rotation_angle=rotation_angle,
                ocr_engine=ocr_engine,
                baidu_api_key=baidu_api_key,
                baidu_secret_key=baidu_secret_key,
                baidu_version=baidu_version,
                ai_vision_provider=ai_vision_provider,
                ai_vision_api_key=ai_vision_api_key,
                ai_vision_model_name=ai_vision_model_name,
                ai_vision_ocr_prompt=ai_vision_ocr_prompt,
                # VVVVVV 新增传递自定义AI视觉Base URL VVVVVV
                custom_ai_vision_base_url=custom_ai_vision_base_url,
                # ^^^^^^ 结束新增 ^^^^^^
                use_json_format_translation=use_json_format_translation, # 假设已获取
                use_json_format_ai_vision_ocr=use_json_format_ai_vision_ocr, # 假设已获取
                custom_base_url=custom_base_url, # 这个是翻译的自定义 base url，假设已获取
                rpd_limit_translation=rpd_limit_translation, # 假设已获取
                rpd_limit_ai_vision_ocr=rpd_limit_ai_vision_ocr # 假设已获取
            )
    
            # ... (处理返回结果， jsonify 等) ...
            # 确保所有变量如 img, font_size, corrected_font_path, inpainting_method,
            # fill_color, inpainting_strength, blend_edges, skip_ocr, remove_only,
            # provided_coords, text_color, rotation_angle, baidu_api_key, etc.
            # 都在此函数中正确获取和定义。上面的示例省略了它们的获取过程。
    
        except Exception as e:
            logger.error(f"翻译图片时发生错误: {e}", exc_info=True) # 使用 exc_info=True 记录完整堆栈
            return jsonify({'error': str(e)}), 500
    
    # ... (文件底部的其他代码) ...
    ```
    *请将上述代码片段中省略的部分替换为您 `translate_api.py` 中 `/translate_image` 路由的实际参数获取和处理逻辑。关键是添加 `custom_ai_vision_base_url` 的获取、校验和传递。*

---

**3.2. 更新后端系统 API (`src/app/api/system_api.py`)**

*   **文件路径:** `src/app/api/system_api.py`
*   **修改内容:**
    *   在 `/test_ai_vision_ocr` 路由函数的开头，从 `request.json` 获取 `custom_ai_vision_base_url`。
    *   在参数检查部分，添加一个条件：如果 `provider` 是 `constants.CUSTOM_AI_VISION_PROVIDER_ID`，但 `custom_ai_vision_base_url` 未提供或为空，则返回一个 400 错误。
    *   在调用 `test_ai_vision_ocr` (位于 `src/interfaces/vision_interface.py`) 时，将 `custom_ai_vision_base_url` 作为新参数传递。

*   **代码演示:**

    ```python
    # src/app/api/system_api.py
    
    from flask import Blueprint, request, jsonify # 已有
    # ... (其他 import)
    from src.interfaces.vision_interface import test_ai_vision_ocr # 确保导入
    from src.shared import constants # 确保导入常量
    
    system_bp = Blueprint('system_api', __name__, url_prefix='/api')
    logger = logging.getLogger("SystemAPI")
    
    # ... (其他路由) ...
    
    @system_bp.route('/test_ai_vision_ocr', methods=['POST'])
    def test_ai_vision_ocr_api():
        """测试AI视觉OCR连接状态的端点"""
        try:
            data = request.json
            if not data:
                return jsonify({'success': False, 'message': '请求数据为空'}), 400
    
            provider = data.get('provider')
            api_key = data.get('api_key')
            model_name = data.get('model_name')
            prompt = data.get('prompt')
            # VVVVVV 新增：获取自定义AI视觉Base URL VVVVVV
            custom_ai_vision_base_url = data.get('custom_ai_vision_base_url') # <<< 获取新的参数
            # ^^^^^^ 结束新增 ^^^^^^
    
            # 检查必要参数
            missing = []
            if not provider: missing.append('provider')
            if not api_key: missing.append('api_key')
            if not model_name: missing.append('model_name')
            # VVVVVV 新增参数检查：如果使用自定义AI视觉OCR，必须提供Base URL VVVVVV
            if provider == constants.CUSTOM_AI_VISION_PROVIDER_ID and not custom_ai_vision_base_url:
                missing.append('custom_ai_vision_base_url (当选择自定义服务时)')
            # ^^^^^^ 结束新增参数检查 ^^^^^^
    
            if missing:
                return jsonify({
                    'success': False,
                    'message': f'缺少必要参数: {", ".join(missing)}'
                }), 400
    
            # ... (已有的 provider 支持检查，测试图片路径获取或创建逻辑) ...
            debug_dir = get_debug_dir()
            test_img_path = os.path.join(debug_dir, "ai_vision_test.png") # 简化，假设测试图片总是存在或创建
            if not os.path.exists(test_img_path):
                # 创建一个简单的测试图像 (逻辑与之前相同)
                try:
                    test_img = Image.new('RGB', (300, 100), color=(255, 255, 255))
                    draw = ImageDraw.Draw(test_img)
                    # 确保 get_font_path 和 DEFAULT_FONT_RELATIVE_PATH 可用
                    from src.shared.path_helpers import get_font_path, resource_path # 重新导入
                    font = ImageFont.truetype(resource_path(constants.DEFAULT_FONT_RELATIVE_PATH), 20)
                    draw.text((10, 40), "AI视觉OCR测试", fill=(0, 0, 0), font=font)
                    test_img.save(test_img_path)
                    logger.info(f"创建了测试图片: {test_img_path}")
                except Exception as img_create_err:
                    logger.error(f"创建测试图片失败: {img_create_err}")
                    return jsonify({'success': False, 'message': f'创建测试图片失败: {img_create_err}'}), 500


            logger.info(f"使用测试图片: {test_img_path}")
    
            # 调用测试函数
            success, result_message = test_ai_vision_ocr( # result -> result_message 以匹配函数签名
                test_img_path,
                provider,
                api_key,
                model_name,
                prompt,
                custom_base_url=custom_ai_vision_base_url # <<< 新增传递
            )
    
            return jsonify({
                'success': success,
                'message': result_message, # 使用 result_message
                'test_image_path': test_img_path
            })
    
        except Exception as e:
            logger.error(f"测试AI视觉OCR连接时发生错误: {str(e)}", exc_info=True)
            return jsonify({
                'success': False,
                'message': f'测试AI视觉OCR连接时发生错误: {str(e)}'
            }), 500
    
    # ... (文件底部的其他代码) ...
    ```
    *同样，请将省略号部分替换为您 `system_api.py` `/test_ai_vision_ocr` 路由的实际逻辑。这里简化了测试图片路径的获取，您需要确保它能正确工作。*

---

