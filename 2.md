**2.1. 更新前端事件绑定 (`src/app/static/js/events.js`)**

*   **文件路径:** `src/app/static/js/events.js`
*   **修改内容:**
    *   找到或添加对 AI 视觉 OCR 服务商选择框 (`#aiVisionProvider`) 的 `change` 事件监听器。
    *   在该监听器中，添加逻辑：如果选中的是自定义服务商，则调用 `ui.toggleCustomAiVisionBaseUrlUI(true)`；否则调用 `ui.toggleCustomAiVisionBaseUrlUI(false)`。
    *   为新增的自定义 Base URL 输入框 (`#customAiVisionBaseUrl`) 添加 `input` 事件监听器，用于实时更新 `state.js` 中的 `customAiVisionBaseUrl`。
    *   修改 `handleTestAiVisionOcr` 函数，增加对自定义服务商选择时 Base URL 是否为空的检查。

*   **代码演示:**

    ```javascript
    // src/app/static/js/events.js
    
    import * as state from './state.js';
    import * as ui from './ui.js';
    import * as api from './api.js';
    import * as constants from './constants.js'; // 确保导入前端常量
    // ... (其他 import)
    
    export function bindEventListeners() {
        // ... (已有的事件绑定) ...
    
        // --- AI视觉OCR相关事件 ---
        // (如果之前有AI视觉OCR的事件绑定，这是修改；如果是全新的，这是新增)
    
        // AI视觉OCR服务商选择变更
        $("#aiVisionProvider").on('change', async function(e) {
            const provider = $(this).val();
            state.setAiVisionProvider(provider); // 更新 state 中的服务商
    
            // VVVVVV 新增逻辑：根据选择显示/隐藏自定义 Base URL 输入框 VVVVVV
            if (provider === constants.CUSTOM_AI_VISION_PROVIDER_ID_FRONTEND) { // 使用前端常量比较
                ui.toggleCustomAiVisionBaseUrlUI(true);
                // 可选: 如果用户切换到自定义，但 Base URL 为空，可以聚焦输入框
                // if (!$("#customAiVisionBaseUrl").val().trim()) {
                //     $("#customAiVisionBaseUrl").focus();
                // }
            } else {
                ui.toggleCustomAiVisionBaseUrlUI(false);
            }
            // ^^^^^^ 结束新增逻辑 ^^^^^^
    
            // --- 已有的火山引擎模型建议逻辑 (保持或调整) ---
            if (provider === 'volcano') {
                // const { getUsedModelsApi } = await import('./api.js'); // 这些 import 最好在文件顶部
                // const { updateModelSuggestions } = await import('./ui.js');
                try {
                    const response = await api.getUsedModelsApi('volcano'); // 使用 api.js 中的函数
                    if (response && response.models) {
                        // ... (更新 datalist 的逻辑保持不变) ...
                        // 示例性地假设 updateModelSuggestions 能够处理 aiVisionModelName 的 datalist
                        ui.updateModelSuggestions(response.models, 'aiVisionModelsList', 'aiVisionModelName');
                    }
                } catch (error) {
                    console.error("获取火山引擎模型建议失败:", error);
                }
            } else {
                // 清除非火山引擎时的模型建议 (如果适用)
                 ui.updateModelSuggestions([], 'aiVisionModelsList', 'aiVisionModelName');
            }
            // --- 结束火山引擎逻辑 ---
    
            // 确保这个变更也被视为全局设置变更，以便在必要时触发重渲染或状态保存
            handleGlobalSettingChange({ target: this }); // 模拟事件对象，this 指向 #aiVisionProvider
        });
    
        // AI视觉OCR API Key, 模型名称, 提示词的 change 事件 (保持不变，它们调用 handleGlobalSettingChange)
        $("#aiVisionApiKey, #aiVisionModelName, #aiVisionOcrPrompt").on('change', handleGlobalSettingChange);
        $("#toggleAiVisionJsonPromptButton").on('click', handleToggleAiVisionJsonPrompt); // JSON切换
        $("#rpdAiVisionOcr").on('change input', function() { // RPD 设置
            const value = $(this).val();
            state.setRpdLimitAiVisionOcr(value);
        });


        // VVVVVV 新增：自定义AI视觉Base URL输入框的 input 事件监听 VVVVVV
        $("#customAiVisionBaseUrl").on('input', function() {
            const url = $(this).val().trim();
            state.setCustomAiVisionBaseUrl(url); // 实时更新 state.js 中的值
            // 如果需要，也可以将此视为一个会触发自动存档或影响“已修改”状态的全局设置变更
            // handleGlobalSettingChange({ target: this }); // 但通常 Base URL 更改不直接触发重渲染
        });
        // ^^^^^^ 结束新增 ^^^^^^
    
        // 测试AI视觉OCR按钮点击 (保持不变，内部逻辑在 handleTestAiVisionOcr 中修改)
        $("#testAiVisionOcrButton").on('click', handleTestAiVisionOcr);
    
        // ... (已有的其他事件绑定) ...
    }


    // ... (已有的事件处理函数，如 preventDefaults, handleDrop, 等) ...


    // 修改 handleTestAiVisionOcr 函数
    function handleTestAiVisionOcr() {
        const provider = $("#aiVisionProvider").val();
        const apiKey = $("#aiVisionApiKey").val();
        const modelName = $("#aiVisionModelName").val();
        const prompt = $("#aiVisionOcrPrompt").val();
    
        if(!apiKey) {
            ui.showGeneralMessage("请输入API Key", "error");
            return;
        }
        if(!modelName) {
            ui.showGeneralMessage("请输入模型名称", "error");
            return;
        }
    
        // VVVVVV 新增：如果选择自定义服务，检查 Base URL 是否填写 VVVVVV
        if (provider === constants.CUSTOM_AI_VISION_PROVIDER_ID_FRONTEND) {
            const customBaseUrl = $("#customAiVisionBaseUrl").val().trim();
            if (!customBaseUrl) {
                ui.showGeneralMessage("自定义AI视觉服务需要填写Base URL！", "error");
                return; // 阻止后续 API 调用
            }
            // 注意：state.customAiVisionBaseUrl 应该已经被 #customAiVisionBaseUrl 的 input 事件更新了
            // 所以 api.js 中的 testAiVisionOcrApi 会自动从 state 中获取
        }
        // ^^^^^^ 结束新增 ^^^^^^
    
        ui.showGeneralMessage("正在测试AI视觉OCR连接...", "info", false);
    
        // api.js 中的 testAiVisionOcrApi 将负责从 state 中获取 customAiVisionBaseUrl
        api.testAiVisionOcrApi(provider, apiKey, modelName, prompt)
            .then(response => {
                if(response.success) {
                    ui.showGeneralMessage(`测试成功: ${response.message}`, "success");
                    // 状态已在各自的 change/input 事件中更新，这里无需重复设置
                } else {
                    ui.showGeneralMessage(`测试失败: ${response.message}`, "error");
                }
            })
            .catch(error => {
                ui.showGeneralMessage(`测试出错: ${error.message || "未知错误"}`, "error");
            });
    }
    
    // ... (文件底部的其他事件处理函数) ...
    ```
    *请确保将上述代码片段整合到您 `events.js` 文件中相应的位置。特别是 `#aiVisionProvider` 的 `change` 事件，如果已存在，请将新逻辑合并进去。*

---

**2.2. 更新前端 API 调用封装 (`src/app/static/js/api.js`)**

*   **文件路径:** `src/app/static/js/api.js`
*   **修改内容:**
    1.  修改 `translateImageApi` 函数：当构造发送给后端的参数 `apiParams` 时，检查是否正在使用自定义 AI 视觉 OCR 服务。如果是，并且 `state.customAiVisionBaseUrl` 有值，则将该 URL 作为 `custom_ai_vision_base_url` 字段添加到 `apiParams` 中。
    2.  修改 `testAiVisionOcrApi` 函数：当构造发送给后端的 `payload` 时，检查 `provider` 是否为自定义 AI 视觉 OCR 服务。如果是，并且 `state.customAiVisionBaseUrl` 有值，则将该 URL 作为 `custom_ai_vision_base_url` 字段添加到 `payload` 中。如果 Base URL 为空，则应返回一个失败的 Promise 或抛出错误。

*   **代码演示:**

    ```javascript
    // src/app/static/js/api.js
    
    import * as state from './state.js'; // 确保导入 state
    import * as constants from './constants.js'; // 确保导入前端常量
    // ... (makeApiRequest 函数和已有的 API 函数) ...
    
    /**
     * 请求翻译或消除文字
     * @param {object} params - 包含所有翻译参数的对象
     * @returns {Promise<object>} - 包含翻译结果的 Promise
     */
    export function translateImageApi(params) {
        // 从 state 中获取当前的 RPD 设置并添加到参数中
        const apiParams = {
            ...params,
            rpd_limit_translation: state.rpdLimitTranslation,
            rpd_limit_ai_vision_ocr: state.rpdLimitAiVisionOcr
        };
    
        // VVVVVV 新增逻辑：为自定义AI视觉OCR添加Base URL VVVVVV
        if (params.ocr_engine === 'ai_vision' && params.ai_vision_provider === constants.CUSTOM_AI_VISION_PROVIDER_ID_FRONTEND) {
            if (state.customAiVisionBaseUrl && state.customAiVisionBaseUrl.trim() !== '') {
                apiParams.custom_ai_vision_base_url = state.customAiVisionBaseUrl;
            } else {
                // 如果 Base URL 为空，翻译请求可能会失败，或者后端会处理此情况。
                // 前端最好在发起请求前就进行校验 (已在 events.js 中添加)。
                // 此处可以加一个警告，或者如果后端不处理空URL，则应在此处阻止请求。
                console.warn("translateImageApi: 尝试使用自定义AI视觉OCR但未提供Base URL。");
            }
        }
        // ^^^^^^ 结束新增逻辑 ^^^^^^
    
        console.log("translateImageApi: 发送的参数（含RPD和可能的自定义视觉Base URL）:", apiParams);
        return makeApiRequest('/api/translate_image', 'POST', apiParams);
    }
    
    // ... (其他 API 函数，如 reRenderImageApi 等) ...
    
    /**
     * 测试AI视觉OCR连接
     * @param {string} provider - 服务提供商(如'siliconflow')
     * @param {string} apiKey - API密钥
     * @param {string} modelName - 模型名称
     * @param {string} prompt - OCR提示词(可选)
     * @returns {Promise<object>}
     */
    export function testAiVisionOcrApi(provider, apiKey, modelName, prompt = null) {
        const payload = {
            provider: provider,
            api_key: apiKey,
            model_name: modelName,
            prompt: prompt
        };
    
        // VVVVVV 新增逻辑：为自定义AI视觉OCR添加Base URL VVVVVV
        if (provider === constants.CUSTOM_AI_VISION_PROVIDER_ID_FRONTEND) {
            if (state.customAiVisionBaseUrl && state.customAiVisionBaseUrl.trim() !== '') {
                payload.custom_ai_vision_base_url = state.customAiVisionBaseUrl;
            } else {
                // 如果 Base URL 为空，测试请求应该失败。
                // 在 events.js 中已经做了检查，这里可以作为最后防线。
                console.error("testAiVisionOcrApi: 自定义AI视觉服务需要填写Base URL！");
                return Promise.reject({ message: "自定义AI视觉服务需要填写Base URL！" });
            }
        }
        // ^^^^^^ 结束新增逻辑 ^^^^^^
    
        return makeApiRequest('/api/test_ai_vision_ocr', 'POST', payload);
    }
    
    // ... (文件底部的其他 API 函数) ...
    ```

