**Saber-Translator 开发手册 (完整修订版)**

**目录**

1.  [项目概述](#1-项目概述)
2.  [技术栈](#2-技术栈)
3.  [环境设置与安装](#3-环境设置与安装)
    *   [3.1 Python 环境](#31-python-环境)
    *   [3.2 依赖安装](#32-依赖安装)
    *   [3.3 模型下载/放置](#33-模型下载放置)
    *   [3.4 API 密钥](#34-api-密钥)
4.  [运行应用](#4-运行应用)
5.  [项目结构详解](#5-项目结构详解)
6.  [后端详解](#6-后端详解)
    *   [6.1 启动入口 (`app.py`)](#61-启动入口-apppy)
    *   [6.2 Web 路由 (`src/app/__init__.py`, `src/app/routes.py` & `app.py`)](#62-web-路由-srcapp__init__py-srcapproutespy--apppy)
    *   [6.3 API 蓝图 (`src/app/api/`)](#63-api-蓝图-srcappapi)
    *   [6.4 核心逻辑 (`src/core/`)](#64-核心逻辑-srccore)
    *   [6.5 模型/服务接口 (`src/interfaces/`)](#65-模型服务接口-srcinterfaces)
    *   [6.6 共享模块 (`src/shared/`)](#66-共享模块-srcshared)
    *   [6.7 插件系统 (`src/plugins/`)](#67-插件系统-srcplugins)
7.  [前端详解](#7-前端详解)
    *   [7.1 静态资源与模板 (`src/app/static/`, `src/app/templates/`)](#71-静态资源与模板-srcappstatic-srcapptemplates)
    *   [7.2 JavaScript 模块 (`src/app/static/js/`)](#72-javascript-模块-srcappstaticjs)
8.  [配置管理](#8-配置管理)
9.  [会话管理详解](#9-会话管理详解)
10. [插件开发指南](#10-插件开发指南)
    *   [10.1 插件目的与能力](#101-插件目的与能力)
    *   [10.2 插件架构](#102-插件架构)
    *   [10.3 创建新插件](#103-创建新插件)
    *   [10.4 实现插件类](#104-实现插件类)
    *   [10.5 钩子 (Hooks)](#105-钩子-hooks)
    *   [10.6 添加用户配置](#106-添加用户配置)
    *   [10.7 访问应用和管理器](#107-访问应用和管理器)
    *   [10.8 插件加载与启用/禁用 (包括默认状态)](#108-插件加载与启用禁用-包括默认状态)
    *   [10.9 示例插件参考](#109-示例插件参考)
    *   [10.10 调试插件](#1010-调试插件)
11. [打包与部署](#11-打包与部署)
12. [维护与功能扩展指南](#12-维护与功能扩展指南)
13. [故障排查](#13-故障排查)

---

### 1. 项目概述

Saber-Translator 是一个功能强大的 AI 漫画/图像翻译工具，旨在提供从图像导入到翻译结果呈现的完整解决方案。它集成了先进的气泡检测、手动标注、多种 OCR 引擎（包括云服务和本地模型）、多样化的大语言模型翻译服务（支持 JSON 格式化输出和 RPD 限制）、多种图像修复技术，以及灵活的文本渲染与精细化编辑功能。项目通过 Flask 后端提供服务，前端采用 jQuery 和 ES6 模块化 JavaScript 实现。其核心特性包括完整的会话保存与加载机制（含自动存档）、可扩展的插件系统以及用户友好的界面。

**核心功能 (基于当前代码):**

*   **图像/PDF 文件导入:** 支持单张/多张图片上传，以及 PDF 文件上传并自动提取其中包含的图像。支持拖拽上传。
*   **气泡检测与标注:**
    *   **自动检测:** 基于 YOLOv5 模型自动识别漫画气泡。
    *   **手动标注模式:** 提供完整的交互式标注工具，允许用户绘制新的气泡框、拖动现有框、通过控制柄调整框的大小、删除选中的框。手动标注的框会优先用于后续的 OCR 和翻译流程。
*   **多 OCR 引擎支持:**
    *   **MangaOCR:** 针对日语漫画优化，支持预加载。
    *   **PaddleOCR:** 支持多种语言的本地 OCR，并尝试自动下载所需模型。
    *   **百度OCR:** 集成百度云 OCR 服务，支持标准版和高精度版，并提供 API 连接测试功能。
    *   **AI 视觉 OCR:** 支持调用基于大型多模态模型（如 LLaVA 类）的云服务（如 SiliconFlow, 火山引擎, Google Gemini）进行 OCR，支持自定义提示词和 JSON 格式输出，并提供 API 连接测试及 RPD 限制功能。
    *   引擎可由用户指定，或根据源语言自动选择。
*   **多翻译引擎/服务:**
    *   **云服务 (需 API Key):** SiliconFlow, DeepSeek, 火山引擎, 彩云小译, 百度翻译, 有道翻译, Google Gemini。
    *   **自定义 OpenAI 兼容服务:** 允许用户配置自定义的 OpenAI API 基础 URL。
    *   **本地部署 (可测试连接):** Ollama, Sakura。
    *   支持自定义翻译提示词，区分漫画整体翻译和单句文本框解释，并**新增对翻译服务 JSON 格式输出的支持**。
    *   **新增对翻译服务 RPD (每分钟请求数) 的限制功能。**
*   **背景修复/填充:**
    *   **纯色填充:** 使用用户选择的颜色填充气泡背景。
    *   **LAMA 智能修复:** 依赖 `sd-webui-cleaner` 库，提供更自然的背景修复效果（可测试连接）。
*   **灵活的文本渲染与编辑:**
    *   支持文本竖排和横排。
    *   提供多种内置字体选择。
    *   支持手动设置字号或自动根据气泡大小调整字号。
    *   允许自定义文本颜色。
    *   支持文本旋转。
    *   **单气泡编辑模式:** 对每个气泡的翻译文本、字体、字号、颜色、方向、旋转角度、**位置偏移**、**独立填充颜色**进行精细调整，并提供实时预览。可将单个气泡的样式应用到所有气泡。
*   **会话管理:**
    *   **保存/另存为:** 将当前工作区的所有图片、翻译结果、手动标注框、编辑设置、UI 配置等完整保存为一个会话项目。
    *   **加载/管理:** 提供模态窗口，列出所有已保存的会话，支持加载、删除和重命名会话。
    *   **自动存档:** 在用户进行关键操作（如翻译、编辑、切换图片、退出模式等）后，自动、静默地将当前工作状态保存到一个特殊的"自动存档"槽位，最大限度防止数据意外丢失。
    *   **优化存储:** 图像的 Base64 数据与会话元数据分离存储，提高加载和保存效率。
*   **插件系统:**
    *   通过钩子机制，允许开发者在图像处理的核心流程（如检测后、OCR 后、翻译后等）中注入自定义逻辑，以扩展或修改应用行为。
    *   提供插件管理界面：查看插件列表、启用/禁用插件、设置插件的默认启用状态（持久化用户偏好）、配置插件参数（如果插件提供）、物理删除插件文件。
*   **其他特性:**
    *   模型使用历史记录。
    *   提供翻译结果的多格式下载 (单张 PNG, 所有图片打包为 ZIP, 所有图片合并为 PDF, 所有图片打包为 CBZ 漫画格式)。
    *   提供调试文件清理功能。
    *   支持亮色/暗色模式切换（用户偏好存储在 `localStorage`）。
    *   应用启动时预加载 YOLOv5 和 MangaOCR 模型，优化首次使用体验。
    *   提供赞助二维码。
    *   详细的后端日志系统，支持彩色控制台输出和按日期分割的文件日志。
    *   前端提供友好的操作反馈和错误提示。

### 2. 技术栈

*   **后端:** Python 3.10+, Flask, Flask-CORS
*   **Web 服务器 (开发):** Flask Development Server (Werkzeug)
*   **AI / 图像处理:**
    *   PyTorch (用于 YOLOv5, MangaOCR, LAMA)
    *   PaddlePaddle-OCR (`paddleocr` 包)
    *   MangaOCR (`manga-ocr` 包)
    *   OpenCV-Python (`opencv-python`)
    *   Pillow (PIL) (`Pillow`)
    *   NumPy
    *   `openai` (Python 库，用于调用 OpenAI 兼容 API 如 SiliconFlow, DeepSeek, 火山引擎, Google Gemini, 以及用户自定义服务)
    *   `litelama` (包含在 `sd-webui-cleaner` 中，用于 LAMA 修复)
    *   `requests` (用于调用 Ollama, Sakura, 百度OCR/翻译, 有道翻译等 API)
*   **前端:**
    *   HTML5
    *   CSS3 (包括 Flexbox 布局)
    *   JavaScript (ECMAScript 6 Modules)
    *   jQuery 3.6+
    *   JSZip (用于打包下载 ZIP/CBZ)
    *   jsPDF (用于生成 PDF 下载)
*   **PDF 处理:** PyPDF2
*   **打包:** PyInstaller (通过 `app.spec` 配置)
*   **配置文件加载:** `src/shared/config_loader.py` (支持 JSON 和 YAML)
*   **其他 Python 库:** `webbrowser`, `threading`, `secrets`, `colorama`, `shutil`, `mimetypes`

### 3. 环境设置与安装

#### 3.1 Python 环境

强烈建议使用 Python 3.10 或更高版本。推荐在项目根目录下创建并激活一个 Python 虚拟环境 (例如使用 `python -m venv venv` 然后 `source venv/bin/activate` 或 `venv\Scripts\activate`)。

#### 3.2 依赖安装

1.  **激活虚拟环境后**，安装项目所需的 Python 包。如果项目提供了 `requirements.txt` 文件，请使用：
    ```bash
    pip install -r requirements.txt
    ```
    如果 `requirements.txt` 不完整或未提供，根据技术栈章节，至少需要安装以下核心库：
    ```bash
    pip install Flask Flask-CORS Pillow opencv-python numpy PyPDF2 requests PyYAML manga-ocr paddleocr paddlepaddle openai colorama torch torchvision torchaudio --index-url https://pypi.tuna.tsinghua.edu.cn/simple
    # 建议使用国内镜像源加速下载，如清华源
    ```

2.  **PyTorch:** 请根据你的操作系统和是否有 NVIDIA GPU（推荐）访问 [PyTorch 官网](https://pytorch.org/) 获取并执行适合你的安装命令。务必选择与你的 CUDA 版本匹配的 PyTorch 版本（如果使用 GPU）。

3.  **PaddlePaddle:** 安装 PaddlePaddle CPU 或 GPU 版本。
    ```bash
    # CPU 版本 (通常足够，且安装简单)
    python -m pip install paddlepaddle -i https://mirror.baidu.com/pypi/simple
    # GPU 版本 (请查阅 PaddlePaddle 官网获取与你 CUDA 版本匹配的最新安装命令)
    ```

4.  **sd-webui-cleaner (LAMA 支持):**
    *   从其 GitHub 仓库 (或你获取的来源) 下载 `sd-webui-cleaner` 的完整代码。
    *   将其**整个文件夹**放置在 Saber-Translator 项目的**根目录下**。
    *   即，你的项目结构中应该有 `Saber-Translator/sd-webui-cleaner/`。
    *   确保 `sd-webui-cleaner` 目录内包含 `litelama` 模块和所需的模型配置文件。

#### 3.3 模型下载/放置

将所需的 AI 模型文件下载并放置到项目根目录下的**指定子目录**中。这些模型通常较大，不包含在代码库中。

1.  **YOLOv5 气泡检测:**
    *   **权重文件:** (例如 `best.pt`) 放入项目根目录下的 `weights/` 目录。
    *   **YOLOv5 代码库:** 将 `ultralytics/yolov5` (或你使用的特定版本) 的代码库文件夹命名为 `ultralytics_yolov5_master` 并放置在项目根目录下。
2.  **MangaOCR:**
    *   模型文件（通常是 `manga-ocr-base` 或类似名称的文件夹）应放置在项目根目录下的 `manga_ocr_model/` 目录中。`manga_ocr_interface.py` 被配置为优先从此路径加载模型。它也配置了环境变量以优先使用本地缓存。
3.  **LAMA 修复 (sd-webui-cleaner):**
    *   LAMA 模型权重文件 (例如 `big-lama.safetensors`) 应放置在 `sd-webui-cleaner/models/` 目录中。`lama_interface.py` 会尝试从此路径加载。
4.  **PaddleOCR:**
    *   PaddleOCR 模型文件会由 `paddle_ocr_interface.py` 在首次为特定语言初始化时尝试自动下载到项目根目录下的 `models/paddle_ocr/` 目录。如果你的运行环境网络受限或为了打包方便，建议预先运行一次应用，选择所有你可能用到的源语言进行一次翻译，以触发模型下载。或者，手动从 PaddleOCR 的 GitHub 仓库下载所需语言的 `det` (检测)、`rec` (识别)、`cls` (方向分类) 模型，并按其要求的目录结构放置在 `models/paddle_ocr/` 下。

#### 3.4 API 密钥

对于需要 API 密钥的云服务，请在应用启动后，通过前端界面的相应设置区域输入：

*   **SiliconFlow / DeepSeek / 火山引擎 / 彩云小译 / 百度翻译 / 有道翻译 / Google Gemini / 自定义 OpenAI 服务:**
    *   在前端界面的 "AI模型设置" -> "翻译服务商" 选择对应服务商后，在 "API Key" (或特定名称如 "App ID", "App Key", "App Secret") 输入框中填入你的密钥。
    *   对于 "自定义 OpenAI 兼容服务"，还需要在 "Base URL" 输入框中填入服务的 API 基础地址。
*   **Ollama / Sakura:** 这些是本地部署模型，通常无需 API Key。
*   **百度OCR:** 在前端界面的 "文字设置" -> "OCR引擎" 选择 "百度OCR" 后，在下方出现的 "百度OCR设置" 中填入你的 API Key 和 Secret Key。
*   **AI 视觉 OCR (如 SiliconFlow LLaVA, 火山引擎, Google Gemini):** 在前端界面的 "文字设置" -> "OCR引擎" 选择 "AI视觉OCR" 后，在下方出现的 "AI视觉OCR设置" 中选择服务商并填入对应服务商的 API Key 和模型名称。

这些密钥通常不会保存在版本控制中，而是由用户自行填入。**请勿将您的 API 密钥提交到公共代码仓库。**

### 4. 运行应用

1.  确保已正确完成第 3 节中的所有环境设置、依赖安装和模型文件放置。
2.  激活你的 Python 虚拟环境。
3.  在项目根目录下打开终端或命令行界面。
4.  执行主应用脚本：
    ```bash
    python app.py
    ```
5.  应用启动后，控制台会显示类似 "程序正在运行，请在浏览器中访问 http://127.0.0.1:5000/" 的信息。
6.  在你的网页浏览器中打开 `http://127.0.0.1:5000/` 即可开始使用。
7.  密切关注控制台的输出信息，以及项目根目录下 `logs/` 目录中生成的日志文件（例如 `comic_translator_YYYY-MM-DD.log`），以便进行调试和问题排查。

### 5. 项目结构详解

(此结构基于您提供的最新代码文件进行确认和调整)

```
Saber-Translator/
├── config/                      # [配置] 配置文件目录
│   ├── plugin_configs/          #     - [配置] 插件的个性化配置 (JSON)
│   ├── model_history.json       #     - [数据] LLM 使用历史
│   ├── plugin_default_states.json #     - [数据] 用户设置的插件默认启用状态
│   ├── prompts.json             #     - [数据] 漫画翻译提示词
│   └── textbox_prompts.json     #     - [数据] 文本框提示词
│
├── data/                        # [运行时数据]
│   ├── debug/                   #     - [运行时数据] 调试输出文件 (可清理)
│   │   ├── bubbles/
│   │   ├── inpainting_masks/
│   │   ├── inpainting_results/
│   │   ├── ocr_bubbles/
│   │   └── paddle_ocr/          #     - PaddleOCR 调试目录
│   ├── sessions/                #     - [用户数据] 用户保存的会话/项目 (非常重要!)
│   │   └── my_saved_session/    #         - 单个会话文件夹示例
│   │       ├── session_meta.json#             - 会话元数据 (UI设置, 图片元信息, 当前索引)
│   │       ├── image_0_original.b64 #       - 分离存储的图像 Base64 数据文件
│   │       └── ...
│   └── uploads/                 #     - [运行时数据] 用户上传的临时文件 (PDF解压等)
│
├── docs/                        # [文档]
│   └── 开发手册.md              #     - 本开发手册
│
├── logs/                        # [运行时数据] 日志文件
│   └── comic_translator_YYYY-MM-DD.log
│
├── models/                      # [资源] AI 模型文件
│   └── paddle_ocr/              #     - PaddleOCR 模型下载目录
│       └── ...
│
├── weights/                     # [资源] YOLOv5 模型权重文件
│   └── best.pt                  #     - YOLOv5 气泡检测权重
│
├── manga_ocr_model/             # [资源] MangaOCR 模型文件 (优先从此加载)
│   └── ...
│
├── pic/                         # [资源] UI 图片 (logo, github, donate) - **注意：现在主要由 static/pic/ 管理**
│   └── ...
│
├── plugins/                     # [用户代码/配置] 用户自定义插件目录 (项目根目录)
│   └── ... (插件子目录，每个子目录是一个插件)
│
├── sd-webui-cleaner/            # [依赖] LAMA 相关代码和模型 (需手动放置在项目根目录)
│   └── ...
│
├── src/                         # [源代码] 项目核心 Python 代码
│   ├── app/                     #     - Flask Web 应用部分
│   │   ├── api/                 #         - API 蓝图定义
│   │   │   ├── __init__.py
│   │   │   ├── config_api.py    #             - 配置管理 API
│   │   │   ├── session_api.py   #             - 会话管理 API
│   │   │   ├── system_api.py    #             - 系统/插件/测试 API
│   │   │   └── translate_api.py #             - 翻译/渲染 API
│   │   ├── static/              #         - 静态文件 (JS, CSS, Fonts, Images)
│   │   │   ├── css/style.css
│   │   │   ├── fonts/           #             - 字体文件
│   │   │   ├── js/              #             - JavaScript 模块
│   │   │   │   ├── api.js
│   │   │   │   ├── constants.js #             - 前端常量
│   │   │   │   ├── edit_mode.js #             - 编辑模式逻辑
│   │   │   │   ├── events.js    #             - 事件绑定
│   │   │   │   ├── labeling_mode.js #         - 手动标注模式逻辑
│   │   │   │   ├── main.js      #             - JS 主入口
│   │   │   │   ├── session.js   #             - 会话管理前端逻辑
│   │   │   │   ├── state.js     #             - 前端状态管理
│   │   │   │   └── ui.js        #             - UI 更新函数
│   │   │   └── pic/             #             - logo.png, favicon.ico, donate-icon.png, github.jpg 等
│   │   ├── templates/           #         - HTML 模板 (Jinja2)
│   │   │   ├── index.html       #             - 主页面模板
│   │   │   └── test_lama.html   #             - LAMA 测试页面模板
│   │   ├── routes.py            #         - 主 Flask 路由 (如 /, /test_lama_page, /pic/<path:filename>)
│   │   └── __init__.py          #         - App 包初始化, 蓝图注册
│   │
│   ├── core/                    #     - 核心处理逻辑 (不直接依赖 Flask)
│   │   ├── __init__.py
│   │   ├── detection.py         #         - 气泡检测
│   │   ├── inpainting.py        #         - 背景修复/填充
│   │   ├── ocr.py               #         - OCR 文本识别
│   │   ├── pdf_processor.py     #         - PDF 图像提取
│   │   ├── processing.py        #         - 核心编排，触发插件钩子
│   │   ├── rendering.py         #         - 文本渲染
│   │   ├── session_manager.py   #         - 会话保存/加载核心逻辑
│   │   ├── translation.py       #         - 文本翻译
│   │   └── image_cleanup.py     #         - (当前为空文件)
│   │
│   ├── interfaces/              #     - 外部模型/库/服务接口封装
│   │   ├── __init__.py
│   │   ├── baidu_ocr_interface.py #      - 百度OCR API 封装
│   │   ├── baidu_translate_interface.py #  - 百度翻译 API 封装
│   │   ├── lama_interface.py    #         - 封装 LAMA (sd-webui-cleaner)
│   │   ├── manga_ocr_interface.py #       - 封装 MangaOCR
│   │   ├── paddle_ocr_interface.py#       - 封装 PaddleOCR
│   │   ├── vision_interface.py  #         - AI 视觉 OCR 接口 (SiliconFlow, Volcano, Gemini)
│   │   ├── youdao_translate_interface.py # - 有道翻译 API 封装
│   │   └── yolo_interface.py    #         - 封装 YOLOv5
│   │
│   ├── plugins/                 #     - 插件系统核心及内置插件 (src/plugins/)
│   │   ├── __init__.py
│   │   ├── base.py              #         - 插件基类 PluginBase
│   │   ├── hooks.py             #         - 钩子常量定义
│   │   ├── manager.py           #         - 插件管理器 PluginManager
│   │   └── ... (内置插件目录，每个子目录是一个插件)
│   │
│   └── shared/                  #     - 项目内共享的工具/常量/类型定义
│       ├── __init__.py
│       ├── config_loader.py     #         - 配置加载/保存工具 (JSON, YAML)
│       ├── constants.py         #         - 后端常量定义
│       ├── image_helpers.py     #         - 图像处理辅助函数 (Base64转换等)
│       └── path_helpers.py      #         - 路径处理工具 (resource_path, get_debug_dir)
│
├── ultralytics_yolov5_master/ # [依赖] YOLOv5 代码库 (需手动放置在项目根目录)
│   └── ...
│
├── app.py                       # [启动脚本] Flask 应用主入口
├── app.spec                     # [构建配置] PyInstaller 打包配置文件 (如果使用)
└── requirements.txt             # [依赖] Python 依赖列表 (应保持最新)
```

### 6. 后端详解

#### 6.1 启动入口 (`app.py`)

*   **职责:**
    *   初始化 Flask 应用实例 (`app = Flask(__name__, ...)`).
    *   配置静态文件和模板文件夹的路径，确保它们指向 `src/app/static` 和 `src/app/templates`。**注意：`static_url_path=''` 使得静态文件可以直接通过根路径访问 (如 `/style.css`)。**
    *   启用 CORS (`CORS(app)`).
    *   生成并设置 Flask 应用密钥 (`app.secret_key`).
    *   创建并配置全局日志系统 (`setup_logging()`)：
        *   支持彩色控制台输出和按日期分割的文件日志。
        *   为不同库（如 Werkzeug, MangaOCR, PaddleOCR, CoreTranslation）配置了特定的日志级别和处理器。
        *   应用启动时打印佛祖保佑 ASCII Art 和系统信息。
        *   **新增对 Loguru 日志库的处理：** 如果 Loguru 存在，则移除其默认控制台处理器，仅保留文件输出，避免与标准日志重复。
    *   显式添加 `.js` 文件的 MIME 类型 (`mimetypes.add_type`).
    *   定义并创建应用所需的文件夹（如 `TEMP_FOLDER`, `UPLOAD_FOLDER`, `logs/`）。
*   **模型预加载:**
    *   应用启动时，尝试预加载 YOLOv5 气泡检测模型 (`load_yolo_model()`).
    *   应用启动时，在后台线程中尝试预加载 MangaOCR 模型 (`preload_manga_ocr()`)。
*   **插件与蓝图:**
    *   初始化 `PluginManager` (`get_plugin_manager(app=app)`).
    *   调用 `plugin_manager.discover_and_load_plugins()` 来发现、加载插件，并根据用户设置或插件默认值启用插件。
    *   通过 `src.app.register_blueprints(app)` 函数注册所有 API 蓝图 (来自 `src/app/api/`) 和主页面蓝图 (`src/app/routes.py` 中的 `main_bp`)。
*   **后台任务:**
    *   使用 `threading.Timer` 在应用启动1秒后自动在浏览器中打开 `http://127.0.0.1:5000/`。
    *   启动 Sakura 服务可用性监控后台线程 (`start_service_monitor()` 来自 `system_api.py`)。
*   **兼容性路由:**
    *   定义了大量 `@app.route(...)` 装饰的重定向函数，将旧的根路径 API (如 `/get_prompts`, `/translate_image`) 重定向到新的 `/api/...` 前缀下的蓝图 API 端点，并保持 HTTP 方法和查询参数（状态码 307 表示方法和主体不应改变）。
*   **启动 Flask 应用:**
    *   在 `if __name__ == '__main__':` 块中，配置并启动 Flask 开发服务器 (`app.run(debug=False, use_reloader=False)`).
    *   禁用了 Flask 默认日志和 Werkzeug 的启动横幅，以使用自定义日志。
    *   **精确控制第三方库日志级别：** 对 PIL, matplotlib, httpx, urllib3, torch, transformers, mangaocr, paddleocr 等库的日志级别进行了设置，以减少不必要的控制台输出。

#### 6.2 Web 路由 (`src/app/__init__.py`, `src/app/routes.py` & `app.py`)

*   **`src/app/__init__.py`**:
    *   定义了 `main_bp` (主蓝图) 和所有 API 蓝图的实例。
    *   `register_blueprints(app)` 函数：将 `main_bp` 和所有 API 蓝图注册到 Flask 应用实例 `app`。
*   **`src/app/routes.py` (`main_bp` 蓝图):**
    *   `/`: 渲染主页面 `index.html`。加载默认的漫画翻译提示词和文本框提示词，并将它们以及已保存的提示词名称列表传递给模板。
    *   `/test_lama_page`: 渲染 LAMA 测试页面 `test_lama.html`。
    *   `/pic/<path:filename>`: **提供对项目根目录下 `pic/` 目录中静态图片资源的访问**（例如 `logo.png`，用于HTML模板中）。这与 Flask 的 `static_folder` 配置是独立的。

#### 6.3 API 蓝图 (`src/app/api/`)

所有 API 路由均以 `/api` 作为前缀（除了会话 API 的 `/api/sessions`）。每个 `*_api.py` 文件定义一个蓝图。

*   **`translate_api.py` (`translate_bp`, 前缀 `/api`):**
    *   `/translate_image` (POST): **核心翻译/消除文字接口**。接收 Base64 图像数据、目标/源语言、字体设置（包括自动字号）、AI模型参数（服务商、API Key、模型名、**自定义 Base URL**）、提示词内容（区分漫画翻译和文本框解释）、修复方法（纯色、LAMA）、颜色（填充、文本）、旋转角度、是否跳过OCR/翻译、是否仅消除文字、**前端提供的手动气泡坐标 (`bubble_coords`)**、OCR引擎选择以及特定OCR引擎（百度、AI视觉）的参数、**是否使用 JSON 格式进行翻译/AI视觉OCR**、**RPD 限制参数**。调用 `src.core.processing.process_image_translation`。返回处理后的图像、干净背景图像、原始/翻译文本、气泡坐标。
    *   `/re_render_image` (POST): **重新渲染整个图像**。接收当前图像、**干净背景图像 (`clean_image`)**、所有气泡的文本、所有气泡的坐标、新的全局字体/颜色/方向/旋转设置，以及**所有气泡的独立样式列表 (`all_bubble_styles`)**。优先使用干净背景，然后根据传入的样式重新绘制所有文本。
    *   `/re_render_single_bubble` (POST): **重新渲染单个气泡**。接收图像数据、干净背景数据、目标气泡索引、所有文本列表、所有坐标、**所有气泡的当前样式列表**，以及该目标气泡的特定新样式（字号、字体、方向、偏移、颜色、旋转、**独立填充色**）。后端会更新目标气泡的样式，然后调用 `render_all_bubbles` 重新渲染整张图。
    *   `/apply_settings_to_all_images` (POST): 将当前图片的字体、颜色、方向等设置应用到会话中的所有已处理图片上，并批量重新渲染它们。
    *   `/translate_single_text` (POST): 翻译单段文本，接收原文、目标语言、AI模型参数（包括**自定义 Base URL** 和 **JSON 格式标记**）、**RPD 限制参数**。
*   **`config_api.py` (`config_bp`, 前缀 `/api`):**
    *   管理模型使用历史 (`/get_model_info`, `/get_used_models`, `/save_model_info`)。
    *   管理漫画翻译提示词 (`/get_prompts`, `/save_prompt`, `/get_prompt_content`, `/reset_prompt_to_default`, `/delete_prompt`)。
    *   管理文本框解释提示词 (类似漫画提示词的接口)。
*   **`system_api.py` (`system_bp`, 前缀 `/api`):**
    *   PDF 上传与图片提取 (`/upload_pdf`)。
    *   清理调试文件 (`/clean_debug_files`)。
    *   连接测试: Ollama (`/test_ollama_connection`), Sakura (`/test_sakura_connection`, 支持强制刷新), LAMA (`/test_lama_repair`)。
    *   **新增连接测试**: 百度OCR (`/test_baidu_ocr_connection`)，AI视觉OCR (`/test_ai_vision_ocr`)，百度翻译 (`/test_baidu_translate_connection`)，有道翻译 (`/test_youdao_translate`)。
    *   参数测试 (`/test_params`)。
    *   **仅气泡检测** (`/detect_boxes`): 接收图片和置信度，返回检测到的气泡坐标。
    *   **插件管理 API:**
        *   `/plugins` (GET): 获取所有已加载插件的列表及其元数据和当前启用状态。
        *   `/plugins/<plugin_name>/enable` (POST): 启用指定插件。
        *   `/plugins/<plugin_name>/disable` (POST): 禁用指定插件。
        *   `/plugins/<plugin_name>` (DELETE): 物理删除指定插件的文件夹。
        *   `/plugins/<plugin_name>/config_schema` (GET): 获取插件的配置项规范。
        *   `/plugins/<plugin_name>/config` (GET/POST): 获取或保存插件的配置值。
        *   `/plugins/default_states` (GET): 获取所有插件的用户设置的默认启用/禁用状态。
        *   `/plugins/<plugin_name>/set_default_state` (POST): 设置指定插件的默认启用/禁用状态。
*   **`session_api.py` (`session_bp`, 前缀 `/api/sessions`):**
    *   `/save` (POST): 保存当前会话状态（UI设置、所有图片状态包括Base64数据、当前图片索引、**手动标注框等**）到指定名称的会话。
    *   `/list` (GET): 列出所有已保存的会话元数据（名称、保存时间、图片数量、版本）。
    *   `/load` (GET): 加载指定名称的会话数据。
    *   `/delete` (POST): 删除指定名称的会话。
    *   `/rename` (POST): 重命名指定的会话。

#### 6.4 核心逻辑 (`src/core/`)

*   **`processing.py` (`process_image_translation`):**
    *   **核心业务流程编排器。**
    *   接收原始图像和大量处理参数。
    *   **协调调用**：
        1.  插件钩子: `BEFORE_PROCESSING` (可修改输入图像和所有参数)。
        2.  `detection.get_bubble_coordinates` (如果未提供 `provided_coords`)。
        3.  插件钩子: `AFTER_DETECTION` (可修改气泡坐标)。
        4.  插件钩子: `BEFORE_OCR`。
        5.  `ocr.recognize_text_in_bubbles` (如果 `skip_ocr` 为 False)，传递OCR引擎及相关参数（包括百度OCR/AI视觉OCR的API Key, 模型名, 提示词, JSON格式标记, RPD限制）。
        6.  插件钩子: `AFTER_OCR` (可修改原始文本)。
        7.  插件钩子: `BEFORE_TRANSLATION` (可修改待翻译文本和翻译参数)。
        8.  `translation.translate_text_list` (如果 `skip_translation` 为 False)，分别处理漫画翻译和文本框解释（如果启用），传递翻译服务商, API Key, 模型名, 提示词, JSON格式标记, 自定义Base URL, RPD限制。
        9.  插件钩子: `AFTER_TRANSLATION` (可修改翻译结果)。
        10. 插件钩子: `BEFORE_INPAINTING`。
        11. `inpainting.inpaint_bubbles` (选择纯色填充、LAMA)。
        12. 插件钩子: `AFTER_INPAINTING` (可修改修复后图像和干净背景)。
        13. 插件钩子: `BEFORE_RENDERING` (可修改渲染参数)。
        14. `rendering.render_all_bubbles` (使用计算得到的初始样式)。
        15. 插件钩子: `AFTER_PROCESSING` (可修改最终图像和结果)。
    *   返回处理后的图像、原始文本、翻译文本（气泡和文本框）、气泡坐标和应用的初始样式。
*   **`detection.py` (`get_bubble_coordinates`):**
    *   调用 `src.interfaces.yolo_interface.detect_bubbles` 来获取气泡的边界框。
    *   对检测结果按宽度进行排序。
*   **`ocr.py` (`recognize_text_in_bubbles`):**
    *   根据传入的 `ocr_engine` 参数和 `source_language` 自动选择或直接使用指定的 OCR 引擎。
    *   调用相应的接口模块 (`manga_ocr_interface`, `paddle_ocr_interface`, `baidu_ocr_interface`, `vision_interface`) 进行文本识别。
    *   为百度 OCR 和 AI 视觉 OCR 传递所需的 API Key、模型名、提示词、JSON格式标记和 RPD 限制。
    *   **新增对 AI Vision OCR 结果的安全 JSON 解析。**
*   **`translation.py` (`translate_text_list`, `translate_single_text`):**
    *   根据 `model_provider` 调用不同的翻译服务：
        *   SiliconFlow, DeepSeek, Volcano, Google Gemini, **自定义 OpenAI 服务**: 使用 `openai` SDK 调用其 OpenAI 兼容 API，支持传递**自定义 Base URL**。
        *   Ollama, Sakura: 通过 `requests` 调用本地部署的 API。
        *   彩云小译: 通过 `requests` 调用其 API。
        *   百度翻译: 使用 `baidu_translate_interface.py`。
        *   有道翻译: 使用 `youdao_translate_interface.py`。
    *   实现了重试逻辑和基本的错误处理。
    *   包含一个 `translate_with_mock` 函数用于测试。
    *   **新增对翻译服务 JSON 格式输出的安全解析。**
    *   **新增 `_enforce_rpd_limit` 函数用于实现 RPD 限制。**
*   **`inpainting.py` (`inpaint_bubbles`, `create_bubble_mask`):**
    *   `create_bubble_mask`: 创建用于修复的掩码，黑色区域表示需要修复。**掩码创建逻辑有优化**，更精细地处理气泡边缘，并对过大掩码进行收缩。
    *   `inpaint_bubbles`: 根据 `method` 参数选择修复方式：
        *   `'solid'`: 使用 `fill_color` 进行纯色填充。
        *   `'lama'`: 调用 `lama_interface.clean_image_with_lama` 进行修复。
    *   返回修复后的图像和可选的干净背景图像。
*   **`rendering.py`:**
    *   `get_font`: 带缓存的字体加载函数，支持从相对路径加载。
    *   `calculate_auto_font_size`: 使用二分法计算在给定气泡尺寸和文本内容下的最佳字体大小。
    *   `draw_multiline_text_vertical`, `draw_multiline_text_horizontal`: 实现竖排和横排文本的绘制，**支持文字旋转**。
    *   `render_all_bubbles`: 核心渲染函数，遍历所有气泡，根据每个气泡的样式（包括自动计算的字号、颜色、旋转、偏移等）调用绘制函数将文本渲染到图像上。
    *   `render_single_bubble`: （在 `translate_api.py` 中调用）通过更新目标气泡的样式，然后调用 `render_all_bubbles` 来实现单个气泡的重渲染。现在会优先使用图像上已有的干净背景，如果不存在则执行修复/填充。
    *   `re_render_text_in_bubbles`: （在 `translate_api.py` 中调用）用于全局样式变更后的重渲染，它会重新应用修复（如果需要干净背景）并调用 `render_all_bubbles`。
*   **`pdf_processor.py` (`extract_images_from_pdf`):** 使用 PyPDF2 从 PDF 文件流中提取所有图像。**改进了对不同 PDF 结构和 PyPDF2 版本的兼容性。**
*   **`session_manager.py`:**
    *   **核心会话持久化逻辑。**
    *   定义会话保存的基础目录 (`data/sessions/`) 和元数据文件名。
    *   `_get_session_base_dir`, `_get_session_path`: 路径管理。
    *   `_save_image_data`, `_load_image_data`: 将 Base64 图像数据与元数据分离，分别保存/加载到单独的 `.b64` 文件中。
    *   `save_session`: 将完整的会话数据（UI 设置、图片列表元数据、当前图片索引）保存到指定会话名称的文件夹中。
    *   `load_session`: 从指定会话文件夹加载 `session_meta.json`，并根据图片元数据从分离文件中加载 Base64 图像数据，重构完整的会话对象。
    *   `list_sessions`: 扫描会话基础目录，读取每个会话的元数据文件，返回所有会话的摘要信息。
    *   `delete_session`: 删除指定会话的整个文件夹。
    *   `rename_session`: 重命名会话文件夹，并更新其元数据文件中的会话名称。
*   **`image_cleanup.py`:** (当前仍然为空文件)

#### 6.5 模型/服务接口 (`src/interfaces/`)

这些模块封装了与具体 AI 模型、库或第三方服务 API 的直接交互。

*   `yolo_interface.py`: 加载本地 YOLOv5 模型 (`torch.hub.load`) 并执行气泡检测。支持动态调整置信度。**增加了对 PyTorch Hub `trust_repo` 参数的处理，以兼容不同版本。**
*   `manga_ocr_interface.py`: 加载 MangaOCR 模型（单例），并提供文本识别函数。包含预加载逻辑和模型缓存目录配置，**增强了离线加载和 torch 优化设置。**
*   `paddle_ocr_interface.py`: `PaddleOCRHandler` 类，负责初始化 PaddleOCR 引擎（支持多语言，**自动下载并整理模型文件到 `models/paddle_ocr/`**），并提供在指定气泡坐标内识别文本的接口。**适配了 PaddleOCR 2.6+ 的结果格式。**
*   `baidu_ocr_interface.py`: `BaiduOCRInterface` 类，封装了调用百度云 OCR API 的逻辑，包括获取 Access Token、处理不同 OCR 版本（标准版/高精度版）、语言参数映射、请求间隔控制和错误重试。
*   `vision_interface.py`: `call_ai_vision_ocr_service` 函数，根据 `provider` 参数调用不同 AI 视觉模型的 OCR 服务（目前支持 SiliconFlow, 火山引擎, **Google Gemini**）。包含图像转 Base64 和构造特定 API 请求的逻辑。`test_ai_vision_ocr` 用于测试。
*   `lama_interface.py`: 检查 `sd-webui-cleaner` 是否存在并尝试导入 `litelama`。如果成功，则 `LAMA_AVAILABLE` 为 `True`。`clean_image_with_lama` 函数使用 LAMA 模型进行图像修复，**注意它内部处理了掩码的反转**（因为 LAMA 需要白色区域为修复区）。**代码结构调整为直接使用 `LiteLama2` 类，模仿了旧的单例行为。**
*   `baidu_translate_interface.py`: `BaiduTranslateInterface` 类，封装百度翻译通用 API，包括签名生成和错误处理。
*   `youdao_translate_interface.py`: `YoudaoTranslateInterface` 类，封装有道智云文本翻译 API，包括签名生成和错误处理。

#### 6.6 共享模块 (`src/shared/`)

*   `constants.py`: 定义了项目中广泛使用的常量字符串和配置值。**新增了大量常量，如自定义 OpenAI 服务商 ID, JSON 格式提示词, RPD 默认值, 更多语言映射。**
*   `path_helpers.py`:
    *   `resource_path`: 核心函数，用于在开发环境和 PyInstaller 打包环境中都能正确获取资源文件的绝对路径。
    *   `get_debug_dir`: 获取或创建 `data/debug/` 目录（及其子目录）的路径。
    *   `is_packaged`: 检测是否在打包环境中运行。
    *   `get_font_path`: 根据传入的相对或绝对字体路径，解析并返回字体文件的最终绝对路径。
*   `config_loader.py`: 提供加载和保存 JSON 及 YAML 配置文件的通用函数 (`load_json_config`, `save_json_config`, `load_yaml_config`, `save_yaml_config`)。所有配置文件都集中在项目根目录的 `config/` 文件夹下。
*   `image_helpers.py`: 包含图像处理相关的辅助函数，如 `image_to_base64` (PIL 到 Base64)，`base64_to_image` (Base64 到 PIL)，`create_mask` (根据坐标创建掩码)，`blend_images` (图像混合)，`resize_image_to_fit` (保持比例缩放图像)。

#### 6.7 插件系统 (`src/plugins/`)

*   `base.py`: 定义 `PluginBase` 类，所有插件都应继承此类。它包含：
    *   插件元数据属性 (name, version, author, description, enabled_by_default)。
    *   `setup()` 方法，用于插件初始化。
    *   `enable()`, `disable()`, `is_enabled()` 方法管理插件的运行时状态。
    *   一系列可被子类覆盖的钩子方法 (如 `before_processing`, `after_ocr` 等)。
    *   `get_config_spec()` 方法，插件通过此方法声明其可配置项。
    *   `load_config()` 方法，用于加载用户配置到插件实例。
*   `hooks.py`: 定义了所有可用的钩子点名称常量 (如 `BEFORE_PROCESSING`, `AFTER_DETECTION` 等)。
*   `manager.py`: `PluginManager` 类是插件系统的核心。
    *   负责在指定的插件目录 (`src/plugins/` 和项目根目录下的 `plugins/`) 中发现插件。
    *   动态加载插件模块和插件类。
    *   实例化插件，调用其 `setup()` 方法。
    *   **管理插件的默认启用状态**：
        *   从 `config/plugin_default_states.json` 加载用户对每个插件的默认启用偏好。
        *   如果某个插件没有用户偏好，则使用插件自身定义的 `plugin_enabled_by_default` 值。
        *   如果发现新插件，会将其默认状态（基于插件自身定义）添加到 `plugin_default_states` 中并保存该文件。
        *   提供 API (`set_plugin_default_state`) 允许前端更改并持久化插件的默认启用状态。
    *   根据最终确定的默认状态（用户偏好优先）在启动时自动启用或禁用插件。
    *   管理插件的运行时启用/禁用状态。
    *   注册插件实现的钩子方法。
    *   `trigger_hook()`: 核心方法，当特定事件发生时，调用所有已注册并启用的插件的对应钩子方法。它能处理钩子对数据的修改（如果钩子返回修改后的数据）。
    *   管理插件的配置文件：从 `config/plugin_configs/` 目录加载插件的个性化配置 (JSON 格式)，并将配置数据传递给插件实例的 `load_config()` 方法。提供 `save_plugin_config` 方法允许插件通过 API 保存其配置。
    *   支持通过 API 物理删除插件（删除插件文件夹）。

### 7. 前端详解

#### 7.1 静态资源与模板 (`src/app/static/`, `src/app/templates/`)

*   **`src/app/static/`**: 存放 CSS (`css/style.css`)、JavaScript 模块 (`js/`)、字体文件 (`fonts/`) 和 UI 图片 (`pic/`，如 logo, favicon, donate QR codes, GitHub icon)。这些资源通过 Flask 的 `static_folder` 配置提供服务，由于 `static_url_path=''`，它们可以通过根路径直接访问（例如，`/css/style.css`）。
*   **`src/app/templates/index.html`**: 项目的单页应用 (SPA) 主 HTML 模板。使用 Jinja2 模板引擎，这允许在后端渲染时注入动态数据（例如，通过 `render_template` 传递的 `prompt_names`, `default_prompt_content` 等）。
    *   **页面结构:** 定义了整个应用的布局，包括顶部横幅、左侧设置栏、中间图片展示/编辑区、右侧缩略图栏，以及各种模态弹窗（赞助、插件管理、会话管理）。
    *   **UI 控件:** 包含所有用户可交互的元素，如选择框、输入框、滑块、按钮等，用于配置翻译参数、管理图片、与插件和会话交互。
    *   **新增 UI 元素:**
        *   为 AI 视觉 OCR 增加了服务商选择、API Key、模型名称、提示词输入框和测试按钮。
        *   为翻译服务和 AI 视觉 OCR 增加了 RPD（每分钟请求数）设置输入框。
        *   为漫画翻译提示词和 AI 视觉 OCR 提示词增加了“使用JSON提示词”的切换按钮。
        *   为自定义 OpenAI 兼容服务增加了 Base URL 输入框。
        *   编辑模式下，为单个气泡增加了独立填充颜色选择器。
    *   **表单和容器:** 包含了文件上传区域 (`#drop-area`)、图片显示区域 (`#translatedImageDisplay`)、编辑模式容器 (`#editModeContainer`)、标注工具按钮容器、文本信息区域等。
    *   **动态内容区域:** 很多区域（如缩略图列表 `#thumbnailList`，插件列表 `#pluginListContainer`，会话列表 `#sessionListContainer`）的内容是由 JavaScript 动态填充的。
*   **`src/app/static/css/style.css`:**
    *   提供了非常详尽的样式规则，覆盖了应用的所有视觉方面。
    *   **主题支持:** 实现了亮色模式 (`body.light-mode`) 和暗色模式 (`body.dark-mode`) 的样式。
    *   **布局:** 使用 Flexbox 等现代 CSS 技术进行页面布局。
    *   **组件样式:** 为按钮、输入框、卡片、模态框、进度条、下拉菜单、滑块、高亮标注框、调整大小手柄等都定义了特定的样式。
    *   **响应式考虑:** (虽然未明确提及，但通常现代 CSS 会包含一些响应式设计元素)。
    *   **动画与过渡:** 包含一些简单的 CSS 动画（如加载指示器、消息滑入）和过渡效果，提升用户体验。

#### 7.2 JavaScript 模块 (`src/app/static/js/`)

前端采用 ES6 模块化组织代码，提高了代码的可维护性和复用性。

*   **`main.js`:**
    *   **应用入口与初始化:** `initializeApp` 函数是前端应用的主入口，负责调用其他模块进行状态初始化、UI 初始化（包括提示词、模型列表、可折叠面板、主题模式）、事件绑定等。
    *   **核心业务流程控制:** 包含处理文件上传 (`handleFiles`)、图片切换 (`switchImage`)、发起翻译 (`translateCurrentImage`, `translateAllImages`)、仅消除文字 (`removeBubbleTextOnly`)、下载图片 (`downloadCurrentImage`, `downloadAllImages`)、应用全局设置到所有图片 (`applySettingsToAll`) 等核心功能的函数。
    *   **与 API 模块交互:** 调用 `api.js` 中的函数向后端发送请求，并处理响应。
    *   **状态与 UI 协调:** 在执行操作时，会更新 `state.js` 中的状态，并调用 `ui.js` 中的函数来更新用户界面。
    *   **辅助函数:** 包含如 `loadImage` (加载图片 Promise) 和 `sortImagesByName` (排序图片) 等。
    *   **新增 `reRenderWithNewFillColor`:** 当全局填充颜色改变时，此函数负责重新生成带有新填充色的干净背景，并触发 `editMode.reRenderFullImage` 进行文本重绘。
*   **`state.js`:**
    *   **中央状态存储:** 定义并管理前端应用的所有核心状态变量。
    *   **图片状态:** `images` 数组存储了每张图片的对象，包括 Base64 数据 (`originalDataURL`, `translatedDataURL`, `cleanImageData`)、文件名、OCR 结果 (`originalTexts`)、翻译结果 (`bubbleTexts`, `textboxTexts`)、气泡坐标 (`bubbleCoords`)、**手动标注坐标 (`savedManualCoords`)**、**是否有未保存的标注更改 (`hasUnsavedChanges`)**，以及与该图片关联的渲染设置（字号、字体、方向、颜色、**独立气泡样式 `bubbleSettings`** 等）。
    *   **当前状态:** `currentImageIndex` 记录当前操作的图片索引。
    *   **模式状态:** `editModeActive` (是否处于单气泡编辑模式)，`isLabelingModeActive` (是否处于手动标注模式)。
    *   **编辑/标注相关状态:** `selectedBubbleIndex` (编辑模式下选中的气泡索引)，`bubbleSettings` (编辑模式下当前图片所有气泡的实时样式设置)，`initialBubbleSettings` (进入编辑模式时对 `bubbleSettings` 的备份，用于重置)，`manualBubbleCoords` (标注模式下当前图片的手动标注框坐标)，`selectedManualBoxIndex` (标注模式下选中的框索引)，`hasUnsavedChanges` (标注模式下是否有未保存的更改)。
    *   **会话状态:** `currentSessionName` 存储当前活动的会话名称。
    *   **提示词状态:** 存储漫画翻译和文本框解释的当前编辑内容、默认内容、已保存名称列表，以及**是否启用 JSON 格式提示词的标记 (`isTranslateJsonMode`, `isAiVisionOcrJsonMode`)**。
    *   **默认设置值:** 存储字号、字体、颜色等全局默认值。
    *   **OCR 引擎状态:** `ocrEngine` (当前选择的 OCR 引擎)、百度 OCR 版本、AI 视觉 OCR 的服务商/模型名/提示词。
    *   **RPD 状态:** `rpdLimitTranslation`, `rpdLimitAiVisionOcr` 存储用户设置的每分钟请求数限制。
    *   **批量处理状态:** `isBatchTranslationInProgress` 标记批量翻译是否正在进行。
    *   **状态更新函数:** 提供一系列 `set...` 和 `get...` 函数来安全地访问和修改这些状态变量，并在更新时打印日志。
*   **`ui.js`:**
    *   **DOM 操作中心:** 封装了所有直接与 HTML DOM 元素交互的代码。
    *   **UI 元素更新:** 负责更新页面上各种元素的显示内容、状态（启用/禁用、显示/隐藏）、样式等。例如：
        *   加载/错误/通用消息提示 (`showLoading`, `hideLoading`, `showError`, `hideError`, `showGeneralMessage`, `clearGeneralMessageById`)。
        *   图片显示区域 (`updateTranslatedImage`, `showResultSection`, `updateImageSizeDisplay`)。
        *   缩略图列表 (`renderThumbnails`，现在支持显示翻译失败和手动标注标记)。
        *   按钮状态 (`updateButtonStates`, `updateNavigationButtons`, `updateRetranslateButton`)。
        *   检测到的文本信息 (`updateDetectedTextDisplay`)。
        *   进度条 (`updateProgressBar`)。
        *   提示词下拉列表 (`populatePromptDropdown`)。
        *   模型相关 UI（如 Ollama/Sakura 模型按钮列表 `updateOllamaModelList`/`updateSakuraModelList`，API Key 输入框状态 `updateApiKeyInputState`，特定服务商 UI 切换 `toggleOllamaUI` 等）。
        *   **编辑模式 UI:** `updateBubbleListUI` (气泡列表), `updateBubbleEditArea` (单个气泡编辑表单), `updateBubbleHighlight` (在图片上高亮气泡框), `toggleEditModeUI` (切换编辑模式整体界面)。
        *   **标注模式 UI:** `drawBoundingBoxes` (绘制所有手动标注框，支持选中高亮和显示调整手柄), `clearBoundingBoxes` (清除所有框), `toggleLabelingModeUI` (切换标注模式整体界面，包括工具按钮)。
        *   **插件管理 UI:** `renderPluginList` (渲染插件列表到模态框，包含启用/禁用开关、**默认启用开关**、删除和设置按钮), `showPluginConfigModal` (根据插件规范动态生成配置表单)。
        *   **会话管理 UI:** `renderSessionList` (渲染会话列表到模态框，**区分自动存档和常规存档项**), `showSessionManagerModal`, `hideSessionManagerModal`。
        *   **新增 UI 更新函数:** `updateTranslatePromptUI`, `updateAiVisionOcrPromptUI` (更新 JSON 切换按钮状态和文本框内容), `toggleCustomOpenAiUI` (显隐自定义 Base URL 输入框), `updateRpdInputFields` (更新 RPD 输入框的值)。
    *   **辅助函数:** `calculateImageDisplayMetrics` 用于精确计算图片在 `object-fit: contain` 约束下的实际显示尺寸、缩放比例和偏移，这对坐标转换（屏幕坐标 <=> 图像原生坐标）至关重要。
*   **`api.js`:**
    *   **后端 API 接口层:** 封装了所有使用 jQuery `$.ajax` 对后端 Flask API 的请求。
    *   **请求封装:** `makeApiRequest` 作为通用的请求函数，处理 GET/POST、数据序列化 (JSON 或 FormData)、Content-Type 设置、以及 Promise 化的成功/失败回调。
    *   **接口对应:** 为每个后端 API 端点（如 `/api/translate_image`, `/api/sessions/save`, `/api/plugins` 等）都提供了一个对应的 JavaScript 函数，方便其他模块调用。
    *   **新增 API 调用函数:** 增加了对新后端 API 的调用，例如测试各种 OCR/翻译服务的连接、获取/设置插件默认状态、仅检测框 (`detectBoxesApi`)。
    *   **参数传递:** 在调用翻译和 AI 视觉 OCR 相关 API 时，会从 `state.js` 获取并传递当前的 RPD 限制参数和 JSON 格式化输出偏好。
*   **`events.js`:**
    *   **事件处理中心:** 集中绑定了页面上几乎所有用户交互元素的事件监听器（如点击、选择、输入、拖拽、鼠标移动/按下/松开、键盘快捷键等）。
    *   **事件分发:** 捕获到的事件会调用 `main.js`, `edit_mode.js`, `labeling_mode.js`, `session.js`, 或 `api.js` 中的相应处理函数或 API 调用函数。
    *   **全局事件:** 处理如点击页面空白处关闭下拉菜单、窗口大小改变时更新高亮框、全局快捷键等。
    *   **动态元素事件:** 对动态添加的元素（如模型按钮、插件列表项、会话列表项）使用事件委托（`$(document).on(...)` 或父元素 `on(...)`）来绑定事件。
    *   **新增事件绑定:** 为所有新添加的 UI 控件（如 RPD 输入框、JSON 格式切换按钮、自定义 Base URL 输入框、测试连接按钮等）绑定了 `change` 或 `click` 事件。
    *   **`handleGlobalSettingChange`:** 这是一个核心事件处理器，当左侧设置面板中的任何全局设置（如字号、字体、颜色、修复方式、模型参数等）发生变化时被调用。它会更新 `state.js` 中的相应状态，并根据情况触发 `editMode.reRenderFullImage()` 来重新渲染当前图片以反映更改。**此函数已更新以处理所有新增的全局设置。**
    *   **`handleDeleteSelectedBoxClick`:** 在用户确认删除选中的手动标注框后，此函数会**通过 Canvas 操作直接修改当前显示的图像**（无论是原图还是翻译图），从原图中复制被删除框覆盖的区域来“修复”背景。同时，它还会**尝试同步修改 `state.currentImage.cleanImageData`**（如果存在），以保持干净背景的一致性。然后更新状态并重绘标注框。
*   **`constants.js`:**
    *   **前端常量定义:** 存储在 JavaScript 中使用的常量，如 `DEFAULT_PROMPT_NAME` (用于标识默认提示词), `DEFAULT_FILL_COLOR` (默认气泡填充色), **`AUTO_SAVE_SLOT_NAME` (自动存档的内部名称)**, **`AUTO_SAVE_DISPLAY_NAME` (自动存档在UI上显示的名称)**, **`DEFAULT_AI_VISION_OCR_PROMPT` (AI视觉OCR的默认提示词)**, **`DEFAULT_TRANSLATE_JSON_PROMPT` 和 `DEFAULT_AI_VISION_OCR_JSON_PROMPT` (JSON格式的默认提示词)**, **`DEFAULT_RPD_TRANSLATION` 和 `DEFAULT_RPD_AI_VISION_OCR` (RPD默认值)**。
*   **`edit_mode.js`:**
    *   **单气泡编辑逻辑:** 管理进入/退出编辑模式，初始化气泡样式，选择气泡，实时更新单个气泡的文本和各种样式（字体、大小、颜色、方向、旋转、位置偏移、**独立填充色**）。
    *   **`reRenderFullImage`:** 核心渲染函数，当单个气泡样式改变或需要预览时调用。它会收集当前所有气泡的最新文本和样式（区分编辑模式的实时状态、图片自身的独立设置或全局UI设置）。**关键改动：它现在会先根据每个气泡的 `fillColor`（或图片的全局 `fillColor`）在干净背景（优先 `cleanImageData`，其次 `originalDataURL`）上预填充所有气泡区域，生成一个“前端预填充背景”，然后将这个预填充背景和所有文本及样式发送给后端的 `/api/re_render_image` 接口，后端仅负责渲染文本。** 这样做是为了正确处理每个气泡可能拥有不同填充色的情况。
    *   **样式应用与重置:** `applySettingsToAllBubbles` (将当前选中气泡样式应用到全部), `resetCurrentBubble` (重置为进入编辑模式时的初始状态)。
*   **`labeling_mode.js`:**
    *   **手动标注模式逻辑:** 管理进入/退出标注模式，加载当前图片的已有标注框。
    *   **`hasUnsavedChanges` 状态管理:** 在用户进行绘制、移动、缩放、删除标注框等操作时，会设置 `hasUnsavedChanges = true`。在退出模式或切换图片时，会提示用户保存未保存的更改。`state.saveManualCoordsToImage()` 用于将当前 `manualBubbleCoords` 保存到当前图片的 `savedManualCoords` 属性中。
    *   **绘制与交互:**
        *   `handleMouseDownOnImage`: 在图片容器空白处按下鼠标左键开始绘制新的标注框。
        *   `handleMouseMove`: 根据当前操作（绘制、拖动、调整大小）实时更新临时矩形或目标标注框的视觉效果。
        *   `handleMouseUp`: 结束绘制/拖动/缩放操作。将屏幕上的操作结果（框的坐标和尺寸）**使用 `ui.calculateImageDisplayMetrics` 转换回图像的原生坐标系**，然后更新 `state.manualBubbleCoords`。
        *   `handleBoxMouseDown`: 在已绘制的标注框上按下鼠标开始拖动该框。
        *   `handleResizeHandleMouseDown`: 在标注框的调整大小手柄上按下鼠标开始调整框的尺寸。
        *   `handleBoxClick`: 点击标注框以选中它。
    *   **工具按钮功能:**
        *   `handleAutoDetectClick`: 调用后端 `/api/detect_boxes` API 进行自动气泡检测，并用返回结果替换当前的手动标注框。
        *   `handleClearManualBoxesClick`: 清除当前图片所有手动标注框。
        *   `handleDeleteSelectedBoxClick` (移至 `events.js`): 删除当前选中的手动标注框，并通过 Canvas 操作从原图恢复背景。
        *   `handleUseManualBoxesClick`: 将当前所有手动标注框作为 `provided_coords` 参数，调用后端 `/api/translate_image` API 进行一次性的翻译处理。
*   **`session.js`:**
    *   **前端会话状态的收集与恢复:**
        *   `collectCurrentSessionData`: 从 `state.js` 和各个 UI 控件收集当前应用的完整状态，包括所有图片数据（文件名、Base64 编码的原始图/翻译图/干净背景图、气泡坐标、原始/翻译文本、**每个气泡的独立样式 `bubbleSettings`**、**手动标注的坐标 `savedManualCoords`**、**是否有未保存的标注更改 `hasUnsavedChanges`**）和所有全局 UI 设置（如语言、字体、模型、提示词、修复方式、**RPD限制值**、**JSON格式偏好**、**自定义Base URL**等）。
        *   `handleLoadSession`: 当从后端加载会话数据成功后，此函数负责将数据恢复到前端：
            1.  清空当前所有图片和状态。
            2.  用加载的图片数据填充 `state.images`。
            3.  设置 `state.currentImageIndex` 和 `state.currentSessionName`。
            4.  调用 `main.switchImage` 显示会话中记录的当前图片。**重要的是，`switchImage` 可能会根据加载的图片自身保存的旧设置更新部分 UI。**
            5.  **因此，在 `switchImage` 之后，会再次遍历加载的会话数据中的 `ui_settings`，并显式地将这些设置应用到所有相关的 UI 控件上，以确保 UI 完全恢复到会话保存时的状态，覆盖掉 `switchImage` 可能带来的副作用。**
            6.  重新渲染缩略图并更新按钮状态。
    *   **API 调用:** 调用 `api.js` 中的函数与后端 `/api/sessions/...` 端点交互，执行保存、另存为、列出、加载、删除、重命名等操作。
    *   **自动存档:**
        *   `performAutoSave`: 实际执行自动存档的函数。它调用 `collectCurrentSessionData` 获取当前状态，然后调用 `api.saveSessionApi` 将数据保存到后端一个固定的、名为 `AUTO_SAVE_SLOT_NAME` (常量，值为 `__autosave__`) 的会话槽位中。此过程静默进行，成功时会短暂显示提示。
        *   `triggerAutoSave`: 这是外部模块（如 `main.js`, `edit_mode.js`, `labeling_mode.js`）在执行关键操作后调用的函数。它使用 `setTimeout` 来实现节流 (debounce)，默认延迟10秒。如果在延迟期间再次调用，会清除之前的计时器并重新开始计时，从而避免过于频繁的保存操作。**批量翻译进行中时，会自动跳过自动存档。**
    *   **UI 交互:** `showSessionManager` 负责显示会话管理模态框，并触发加载会话列表。模态框中的按钮事件（加载、删除、重命名）绑定在 `events.js` 中，它们会调用 `session.js` 中的相应处理函数。

### 8. 配置管理

*   **后端 (`config/` 目录):**
    *   由 `src/shared/config_loader.py` 模块统一管理。该模块提供了加载和保存 JSON 及 YAML 格式配置文件的函数。所有配置文件都应放置在项目根目录下的 `config/` 文件夹内。
    *   `prompts.json`: 存储用户自定义的漫画翻译提示词和默认提示词。结构通常是 `{"default_prompt": "...", "saved_prompts": [{"name": "...", "content": "..."}, ...]}`。
    *   `textbox_prompts.json`: 存储用户自定义的文本框解释提示词和默认提示词，结构同上。
    *   `model_history.json`: 存储用户使用过的 AI 模型，通常是一个字典，键是模型提供商，值是该提供商下使用过的模型名称列表，例如 `{"ollama": ["llama3", "qwen"], "siliconflow": ["alibaba/Qwen1.5-14B-Chat"]}`。
    *   `plugin_default_states.json`: **新增文件**，存储用户为每个插件设置的默认启用/禁用状态（布尔值）。这是一个字典，键是插件内部名称，值是 `true` 或 `false`。例如 `{"my_filter_plugin": true, "another_plugin": false}`。这会覆盖插件自身定义的默认值。
    *   `plugin_configs/`: **新增子目录**，用于存储每个插件的个性化配置文件。每个插件的配置通常以插件名命名并保存为 JSON 文件 (例如 `my_filter_plugin.json`)。这些配置的内容由插件自身通过 `get_config_spec()` 方法定义。
*   **前端:**
    *   大部分翻译参数设置（如字体、颜色、模型选择等）是临时的，当用户修改时，它们会影响当前翻译操作或通过会话保存。
    *   提示词和模型使用历史会通过 API 与后端 `config/` 目录中的对应 JSON 文件同步。
    *   **亮/暗模式主题偏好**存储在用户浏览器的 `localStorage` 中，键名为 `themeMode`，值为 `'light'` 或 `'dark'`。
    *   **RPD（每分钟请求数）设置、JSON 格式化输出偏好、自定义 OpenAI Base URL** 等新增的 UI 设置，会作为 UI 状态的一部分，通过会话管理功能进行保存和加载。
    *   **当前活动的会话名称 (`currentSessionName`)** 存储在前端 `state.js` 中，用于区分"保存"和"另存为"操作。加载会话后，此状态会被更新为加载的会话名称。

### 9. 会话管理详解

会话管理是项目的核心功能之一，允许用户持久化其工作进度，包括所有图片、翻译结果、编辑状态和 UI 设置。

*   **数据结构:** 一个完整的会话数据对象 (`session_data`) 在前端收集并发送给后端，或从后端加载后在前端恢复，其主要结构如下：
    *   **`ui_settings` (object):** 包含所有左侧设置面板中的选项值，例如：
        *   语言选择 (`targetLanguage`, `sourceLanguage`)
        *   字体设置 (`fontSize`, `autoFontSize`, `fontFamily`, `layoutDirection`, `textColor`, `rotationAngle`)
        *   AI 模型选择 (`modelProvider`, `modelName`, **`customBaseUrl` (如果适用)**)
        *   提示词内容 (`promptContent`, `enableTextboxPrompt`, `textboxPromptContent`)
        *   修复/填充方式 (`useInpaintingMethod` 存的是 `'false'`, `'true'`, 或 `'lama'`), 填充颜色 (`fillColor`), 修复强度 (`inpaintingStrength`), 边缘融合 (`blendEdges`)
        *   OCR引擎选择 (`ocrEngine`) 及特定引擎参数 (如百度 OCR 的 Key/Secret/Version, AI 视觉 OCR 的 Provider/Key/Model/Prompt)
        *   **新增：** JSON 格式化输出偏好 (`isTranslateJsonMode`, `isAiVisionOcrJsonMode` - 这些值虽然在 `state.js` 中管理，但 `collectCurrentSessionData` 可能会基于它们来决定保存哪个版本的提示词，或者直接保存这两个布尔标记)。
        *   **新增：** RPD 限制值 (`rpdLimitTranslation`, `rpdLimitAiVisionOcr`)。
    *   **`images` (array):** 一个图片对象数组，每个图片对象包含：
        *   `fileName` (string): 原始文件名。
        *   `originalDataURL` (string): 原始图像的 Base64 Data URL。
        *   `translatedDataURL` (string | null): 翻译后图像的 Base64 Data URL。
        *   `cleanImageData` (string | null): 由修复过程产生的“干净”背景图像的纯 Base64 数据（不含前缀）。
        *   `bubbleCoords` (array): 检测到或手动标注的气泡坐标 `[[x1,y1,x2,y2], ...]`。
        *   `originalTexts` (array): 对应 `bubbleCoords` 的 OCR 原始文本。
        *   `bubbleTexts` (array): 对应 `bubbleCoords` 的翻译后气泡文本。
        *   `textboxTexts` (array): 对应 `bubbleCoords` 的文本框解释翻译文本。
        *   `bubbleSettings` (object | null): **每个气泡的独立样式设置**。如果为 `null`，表示该图片使用全局 UI 设置。如果非 `null`，则是一个对象，键为气泡索引（字符串形式，如 `"0"`, `"1"`），值为该气泡的样式对象，包含 `fontSize`, `autoFontSize`, `fontFamily`, `textDirection`, `positionOffset` (`{x, y}`), `textColor`, `rotationAngle`, **`fillColor` (独立填充色)**。
        *   `savedManualCoords` (array | null): 如果用户在标注模式下为此图片保存了手动标注框，这些框的坐标会存在这里。
        *   `hasUnsavedChanges` (boolean): 标记在标注模式下，当前 `manualBubbleCoords` 是否与 `savedManualCoords` 有差异且未保存。
        *   其他与图片相关的状态，如 `showOriginal` (是否显示原图), `translationFailed` (标记翻译是否失败), `fillColor` (图片级别的全局填充色，会被 `bubbleSettings` 中的独立填充色覆盖), 以及翻译时使用的修复设置 (`originalUseInpainting`, `originalUseLama`, `inpaintingStrength`, `blendEdges`)。
    *   **`currentImageIndex` (number):** 指示会话加载后应默认显示的图片在 `images` 数组中的索引。
*   **后端 (`src/core/session_manager.py`):**
    *   **分离存储:** 为了优化性能和避免超大 JSON 文件，实际的图像 Base64 数据 (原始图、翻译图、干净背景图) 被分离存储在以会话名命名的文件夹下的 `.b64` 文件中（例如 `image_0_original.b64`）。`session_meta.json` 文件仅存储 `ui_settings`、`images_meta` (图片元数据，不含 Base64 数据，但包含标记指示哪些分离文件存在) 和 `currentImageIndex`。
    *   **操作:**
        *   `save_session`: 接收前端发送的完整 `session_data` 对象。创建会话文件夹，将 `ui_settings` 和 `currentImageIndex` 存入 `session_meta.json`。遍历 `session_data.images`，对每张图片：
            *   将其元数据（除 Base64 字符串外所有属性）存入 `session_meta.json` 的 `images_meta` 数组中。
            *   提取 `originalDataURL`, `translatedDataURL` (如果存在), `cleanImageData` (如果存在) 中的 Base64 部分，并分别调用 `_save_image_data` 保存到对应的 `.b64` 文件。
        *   `load_session`: 读取指定会话的 `session_meta.json` 文件。然后遍历其中的 `images_meta`，根据元数据中的标记（如 `hasOriginalData`）调用 `_load_image_data` 从对应的 `.b64` 文件中加载图像数据，并将其（带 `data:image/...;base64,` 前缀）重新填充回图片对象中，最后重构完整的 `session_data` 对象返回给前端。
        *   `list_sessions`: 扫描 `data/sessions/` 目录，读取每个子目录（即每个会话）下的 `session_meta.json`，提取会话名称、保存时间、图片数量和应用版本等信息，返回一个包含这些摘要信息的列表。
        *   `delete_session`: 使用 `shutil.rmtree` 删除指定会话的整个文件夹。
        *   `rename_session`: 先使用 `os.rename` 重命名会话文件夹，然后读取新文件夹下的 `session_meta.json`，修改其中的 `metadata.name` 字段为新的会话名称，并保存回去。
*   **前端 (`src/app/static/js/session.js`):**
    *   **收集状态 (`collectCurrentSessionData`):** 从 `state.js` 和 UI 控件（通过 jQuery选择器）收集上述数据结构中描述的所有信息，构造成一个完整的 `session_data` 对象。
    *   **保存逻辑:**
        *   `triggerSaveCurrentSession`: 如果 `state.currentSessionName` 有值（即当前有一个已加载或已另存为的会话），则直接调用 `collectCurrentSessionData` 获取当前状态，并请求后端 API 覆盖保存该会话。
        *   `triggerSaveAsSession`: 总是通过 `prompt()` 让用户输入一个新的会话名称。然后调用 `collectCurrentSessionData` 获取当前状态，并请求后端 API 以新名称保存会话。成功后，会更新 `state.currentSessionName` 为这个新名称。
    *   **加载逻辑 (`handleLoadSession`):**
        1.  在加载新会话前，会先尝试正常退出当前的编辑模式 (`editMode.exitEditMode()`) 和标注模式 (`labelingMode.exitLabelingMode(false)`，不提示保存旧模式的更改，因为即将被覆盖)。
        2.  请求后端 API 加载选定会话的 `session_data`。
        3.  调用 `state.clearImages()` 清空前端当前所有图片和相关状态。
        4.  使用加载的 `session_data.images` 更新 `state.images`。
        5.  设置 `state.currentImageIndex` 和 `state.currentSessionName`。
        6.  调用 `ui.renderThumbnails()` 刷新缩略图列表。
        7.  如果加载后有图片，调用 `main.switchImage(state.currentImageIndex)` 来显示会话中记录的当前活动图片。**注意：`switchImage` 内部会根据该图片自身保存的设置（如字号、字体等）来更新一部分 UI 控件。**
        8.  **关键步骤：** 在 `switchImage` 执行完毕后，会再次遍历加载的 `session_data.ui_settings` 对象，并将这些全局 UI 设置显式地应用到所有相关的 UI 控件上（如模型选择、提示词内容、修复方式、RPD 值等）。这是为了确保整个应用的 UI 状态完全恢复到会话保存时的样子，覆盖掉 `switchImage` 可能基于单张旧图片设置所做的临时 UI 调整。
        9.  调用 `ui.updateButtonStates()` 更新所有按钮的可用状态。
        10. 显示加载成功的消息。
    *   **管理界面:** `showSessionManager` 函数调用 API 获取已保存的会话列表，然后由 `ui.renderSessionList` 将这些会话（包括一个特殊的“自动存档”项，如果存在的话）渲染到会话管理模态弹窗中。用户可以通过此界面选择加载、删除或重命名会话。
    *   **自动存档:**
        *   `performAutoSave`: 此函数在后台静默执行。它调用 `collectCurrentSessionData` 获取当前完整状态，然后请求后端 API 将此状态保存到一个名称固定为 `constants.AUTO_SAVE_SLOT_NAME` (即 `__autosave__`) 的特殊会话中。如果保存成功，会短暂显示一个“进度已自动保存”的提示。
        *   `triggerAutoSave`: 应用中的许多关键操作（如翻译完成、编辑模式下应用更改、切换图片、添加/删除图片、退出编辑/标注模式等）完成后会调用此函数。它使用 `setTimeout` 实现了一个节流机制（默认延迟 `AUTO_SAVE_DELAY`，即10秒）：如果在延迟时间内再次触发，之前的计时会被取消并重新开始。这样可以避免因用户连续快速操作而导致过于频繁的保存请求。**如果当前正在进行批量翻译 (`state.isBatchTranslationInProgress` 为 `true`)，则会自动跳过自动存档，以避免干扰批量操作。**

### 10. 插件开发指南

#### 10.1 插件目的与能力

插件系统允许开发者通过编写独立的 Python 模块来扩展或修改 Saber-Translator 的核心功能，而无需直接修改核心代码。插件可以：

*   在图像处理流程的特定阶段（钩子点）介入，读取或修改数据。例如，可以在 OCR 后对文本进行预处理，或在翻译后对译文进行润色。
*   添加新的 OCR 或翻译引擎的接口封装。
*   实现自定义的图像预处理（如增强、去噪）或后处理（如添加水印）步骤。
*   与外部服务集成，例如将翻译结果发送到特定的内容管理系统。
*   在有限程度上添加新的 UI 元素或 API 端点（这通常需要插件与 Flask 应用实例进行更深度的交互，需谨慎设计）。

#### 10.2 插件架构

*   **`PluginBase` (`src/plugins/base.py`):** 所有插件都必须继承的 Python 类。它定义了插件应有的元数据属性（如 `plugin_name`, `plugin_version`, `plugin_author`, `plugin_description`, 以及新增的 `plugin_enabled_by_default`），一个 `setup()` 初始化方法，`enable()/disable()/is_enabled()` 用于管理插件的运行时启用状态，一系列可被子类覆盖的钩子方法（如 `before_processing`, `after_ocr`），以及用于声明和加载插件配置的方法 (`get_config_spec()`, `load_config()`)。
*   **Hooks (`src/plugins/hooks.py`):** 此文件定义了所有可用的钩子点名称常量字符串（例如 `BEFORE_PROCESSING`, `AFTER_DETECTION`, `AFTER_OCR` 等）。插件通过实现与这些常量同名的方法来响应特定事件。
*   **`PluginManager` (`src/plugins/manager.py`):** 这是插件系统的核心控制器。
    *   **发现与加载:** 负责在指定的插件目录中扫描、发现并动态加载有效的插件模块和插件类。
    *   **实例化与设置:** 实例化插件类（传递自身和 Flask app 实例的引用），并调用插件的 `setup()` 方法进行初始化。
    *   **默认启用状态管理:**
        *   从 `config/plugin_default_states.json` 文件加载用户为每个插件设置的持久化默认启用/禁用偏好。
        *   如果一个插件没有用户偏好记录（例如新安装的插件），则会使用该插件类中定义的 `plugin_enabled_by_default` 属性值作为其初始默认状态，并将此状态写入 `plugin_default_states.json` 文件。
        *   应用启动时，会根据这个最终确定的默认状态（用户偏好优先）来自动启用或禁用每个已加载的插件。
    *   **运行时状态管理:** 允许用户通过 UI 实时启用或禁用插件，这个状态仅在当前运行期间有效。
    *   **钩子注册与触发:** 插件实例化的同时，管理器会检查插件是否实现了任何已定义的钩子方法，并将它们注册到对应的钩子点。当主应用逻辑到达某个钩子点时，管理器会调用 `trigger_hook()` 方法，该方法会按顺序执行所有已注册到该钩子点且当前已启用的插件的相应方法。`trigger_hook()` 能够处理钩子对传递数据的修改（如果钩子方法返回了修改后的数据）。
    *   **配置管理:** 为每个插件管理其独立的配置文件（存储在 `config/plugin_configs/插件名.json`）。插件通过 `get_config_spec()` 声明其配置项，管理器负责从文件加载配置数据并传递给插件的 `load_config()` 方法。同时，也提供了 `save_plugin_config()` 方法，允许通过 API 保存插件的配置。
    *   **插件卸载:** 支持通过 API 物理删除插件（即删除插件对应的文件夹）。

#### 10.3 创建新插件

1.  **选择插件目录:**
    *   **内置插件:** 如果是项目核心开发者，且插件功能与主应用紧密相关，可以考虑放在 `src/plugins/` 目录下。
    *   **用户自定义插件:** 推荐放在项目根目录下的 `plugins/` 目录下。如果此目录不存在，请在项目根目录手动创建它。这样做可以保持用户插件与核心代码的分离，方便管理和分享。
2.  **创建插件文件夹:** 在所选的插件目录下（例如 `plugins/`），为你的插件创建一个新的文件夹。文件夹名称应具有唯一性，并能清晰标识插件功能，例如 `my_custom_filter` 或 `advanced_text_processor`。
3.  **创建必要文件:** 在你创建的插件文件夹内，至少需要以下两个文件：
    *   `__init__.py`: 一个空文件。它的存在告诉 Python 该文件夹是一个可导入的包。
    *   `plugin.py`: 这是插件逻辑的主要实现文件。你将在这个文件中定义继承自 `PluginBase` 的插件类。

    例如，一个用户自定义插件的典型结构如下：
    ```
    Saber-Translator/
    ├── plugins/                     # 用户插件目录
    │   └── my_custom_filter/        # 你的插件文件夹
    │       ├── __init__.py
    │       └── plugin.py            # 插件主代码
    ├── src/
    │   └── plugins/                 # 内置插件目录
    │       ├── base.py
    │       ├── hooks.py
    │       └── manager.py
    └── ... (项目其他文件)
    ```

#### 10.4 实现插件类

在你的 `plugin.py` 文件中，你需要定义一个类，该类必须继承自 `src.plugins.base.PluginBase`。

```python
# plugins/my_custom_filter/plugin.py
import logging # 推荐为插件使用独立的 logger
from src.plugins.base import PluginBase
from src.plugins.hooks import AFTER_OCR # 导入你希望插件响应的钩子常量

# 你也可以导入项目核心模块或其他依赖，但要注意潜在的循环导入问题
# from src.core.utils import some_utility_function # 示例

class MyCustomFilterPlugin(PluginBase):
    # 1. 定义插件元数据 (这些是必需的，会被插件管理器读取)
    plugin_name = "我的自定义滤镜"  # 插件的显示名称，应具有唯一性
    plugin_version = "1.0.1"       # 插件的版本号
    plugin_author = "你的名字或组织" # 插件的作者
    plugin_description = "这是一个示例插件，演示如何在OCR识别后对文本应用一个自定义滤镜。" # 插件的功能描述
    plugin_enabled_by_default = True # 布尔值，指示此插件在首次加载且用户未设置偏好时是否应默认启用

    def __init__(self, plugin_manager, app=None):
        """
        插件类的构造函数。
        通常调用父类的构造函数，并可以进行插件实例自身的初始化。
        """
        super().__init__(plugin_manager, app) # 必须调用父类构造函数
        # self.logger 是由 PluginBase 初始化的，可以直接使用，其名称为 "Plugin.你的插件名"
        self.logger.info(f"'{self.plugin_name}' 插件实例已创建。")
        # 示例：插件可能需要的一些内部状态或配置
        self.filter_intensity = self.config.get("intensity", 0.5) # 从加载的配置中获取，或使用默认值

    def setup(self):
        """
        插件设置和一次性初始化方法。
        在插件被插件管理器加载后、应用实际启动前调用。
        你可以在这里进行资源加载、API客户端初始化、检查依赖项等操作。
        如果此方法返回 False，插件管理器会认为插件加载失败，不会注册其钩子。
        """
        self.logger.info(f"'{self.plugin_name}' 正在进行 setup...")
        # 示例：加载一个插件所需的资源文件
        # try:
        #     self.my_resource = self._load_my_plugin_resource()
        # except Exception as e:
        #     self.logger.error(f"加载插件资源失败: {e}")
        #     return False # 返回 False 表示设置失败
        self.logger.info(f"'{self.plugin_name}' setup 完成。")
        return True # 返回 True 表示设置成功

    def on_enable(self):
        """
        当插件从禁用状态变为启用状态时（无论是应用启动时根据默认值启用，还是用户在UI上手动启用），
        此钩子方法会被调用。
        """
        self.logger.info(f"'{self.plugin_name}' 已被启用。当前滤镜强度: {self.filter_intensity}")
        # 可以在这里执行插件启用时需要进行的操作，例如注册到某些事件总线（如果项目有的话）

    def on_disable(self):
        """
        当插件从启用状态变为禁用状态时（例如用户在UI上手动禁用），此钩子方法会被调用。
        """
        self.logger.info(f"'{self.plugin_name}' 已被禁用。")
        # 可以在这里执行插件禁用时需要进行的清理操作

    # 2. 实现你希望插件响应的钩子方法 (方法名必须与 src/plugins/hooks.py 中定义的常量匹配)
    def after_ocr(self, image_pil, original_texts, bubble_coords, params):
        """
        这是一个示例钩子实现，它会在核心OCR识别流程完成后被调用。
        它可以接收OCR的输出（原始文本列表），并有机会修改它们。

        Args:
            image_pil (PIL.Image.Image): 进行OCR的原始PIL图像。
            original_texts (list[str]): OCR引擎识别出的每个气泡的原始文本列表。
            bubble_coords (list[list[int]]): 对应每个文本的气泡坐标列表。
            params (dict): 包含本次处理流程所有参数的字典。

        Returns:
            tuple or None: 如果要修改数据，应返回一个包含修改后数据的元组。
                           对于 after_ocr，如果修改了 original_texts，应返回 (modified_original_texts,)。
                           如果返回 None，表示插件未修改任何数据。
        """
        if not self.is_enabled(): # **重要：在执行任何钩子逻辑前，务必检查插件是否已启用**
            return None

        self.logger.info(f"'{self.plugin_name}' 的 after_ocr 钩子被触发，接收到 {len(original_texts)} 段文本。")
        
        modified_texts = []
        prefix_to_add = self.config.get("filter_prefix", "默认前缀>") # 从插件配置获取前缀

        for i, text in enumerate(original_texts):
            # 示例：给每个识别出的文本添加一个由配置定义的前缀
            processed_text = f"[{prefix_to_add}] {text}"
            modified_texts.append(processed_text)
            if self.config.get("enable_extra_logging", False): # 根据配置决定是否输出更详细日志
                self.logger.debug(f"  气泡 {i} 文本处理: '{text}' -> '{processed_text}'")

        # 插件管理器期望钩子返回一个元组。如果只修改了 original_texts，
        # 返回的元组中第一个元素应该是修改后的文本列表。
        return (modified_texts,) # 注意这里返回的是一个元组，其中包含修改后的列表

    # 3. 实现配置规范 (可选，如果你的插件需要用户配置)
    def get_config_spec(self):
        """
        声明插件的可配置项。
        插件管理器会使用这个规范在UI上为你的插件生成配置表单。
        """
        return [
            {
                "name": "filter_prefix", # 配置项的内部名称 (用于 self.config)
                "label": "自定义滤镜前缀", # 显示给用户的标签
                "type": "text",         # 输入类型: 'text', 'number', 'boolean', 'select'
                "default": "我的滤镜>",   # 该配置项的默认值
                "description": "这个前缀将被添加到每个经过OCR识别的文本前面。" # 对配置项的说明
            },
            {
                "name": "intensity",
                "label": "滤镜强度",
                "type": "number",
                "default": 0.75,
                "description": "设置滤镜的处理强度 (例如 0.0 到 1.0)。"
            },
            {
                "name": "enable_extra_logging",
                "label": "启用详细日志",
                "type": "boolean",
                "default": False,
                "description": "如果勾选，此插件将输出更详细的调试日志信息。"
            },
            {
                "name": "processing_mode",
                "label": "处理模式",
                "type": "select",
                "default": "模式A",
                "options": ["模式A", "模式B", "模式C"], # 'select' 类型需要 options
                "description": "选择插件的处理模式。"
            }
        ]

    # 4. 加载和使用配置 (可选，但如果定义了 get_config_spec，则推荐实现)
    def load_config(self, config_data):
        """
        当插件的配置从文件加载或用户在UI上保存配置后，插件管理器会调用此方法。
        config_data 是一个字典，包含了用户为该插件保存的配置值。
        PluginBase 中的 load_config 会将 config_data 与 get_config_spec 中的默认值合并，
        并填充到 self.config。子类可以覆盖此方法来在配置加载后执行特定逻辑。
        """
        super().load_config(config_data) # **强烈建议调用父类方法，它会负责填充 self.config**
        
        # 现在 self.config 包含了合并后的配置，可以直接使用
        self.filter_intensity = self.config.get("intensity", 0.5) # 使用配置中的值，如果不存在则用后备默认值
        
        # 根据配置调整插件行为，例如日志级别
        if self.config.get("enable_extra_logging", False):
            self.logger.setLevel(logging.DEBUG)
        else:
            self.logger.setLevel(logging.INFO)
            
        self.logger.info(f"'{self.plugin_name}' 配置已重新加载。滤镜前缀: '{self.config.get('filter_prefix')}', 强度: {self.filter_intensity}, 模式: '{self.config.get('processing_mode')}'")

```

#### 10.5 钩子 (Hooks)

钩子是插件与主应用交互的核心机制。`src/plugins/hooks.py` 文件中定义了所有可用的钩子点名称常量。当你的插件类中实现了与这些常量同名的方法时，插件管理器就会在图像处理流程的相应阶段自动调用这些方法。

*   **钩子方法的签名与返回值至关重要：**
    *   你的钩子方法接收的参数必须与 `PluginBase` 中对应钩子方法的定义一致。
    *   如果你的钩子方法修改了传递给它的数据（例如，修改了文本列表或气泡坐标），它**必须**返回一个包含修改后数据的**元组**。元组中元素的顺序和类型也应与原参数对应。
    *   如果钩子方法不打算修改任何数据，或者只是执行一些通知性的操作，它应该返回 `None`。
    *   插件管理器 (`PluginManager.trigger_hook()`) 会按顺序调用所有注册到特定钩子点且已启用的插件的钩子方法。如果一个插件的钩子返回了修改后的数据，这个修改后的数据会成为下一个插件对应钩子方法的输入。

*   **数据修改型钩子 (部分示例，详见 `PluginBase`):**
    *   `before_processing(self, image_pil, params)`: 在所有处理开始前。可修改输入图像和包含所有后续步骤参数的 `params` 字典。返回 `(modified_image_pil, modified_params)`。
    *   `after_detection(self, image_pil, bubble_coords, params)`: 在气泡检测完成后。可修改 `bubble_coords` 列表。返回 `(modified_bubble_coords,)`。
    *   `after_ocr(self, image_pil, original_texts, bubble_coords, params)`: 在 OCR 完成后。可修改 `original_texts` 列表。返回 `(modified_original_texts,)`。
    *   `before_translation(self, original_texts, params)`: 在翻译前。可修改 `original_texts` 列表和 `params` 中的翻译相关设置。返回 `(modified_original_texts, modified_params)`。
    *   `after_translation(self, translated_bubble_texts, translated_textbox_texts, original_texts, params)`: 在翻译后。可修改 `translated_bubble_texts` 和 `translated_textbox_texts` 列表。返回 `(modified_bubble_texts, modified_textbox_texts)`。
    *   `after_inpainting(self, inpainted_image, clean_background, bubble_coords, params)`: 在背景修复/填充后。可修改修复后的图像或生成的干净背景图。返回 `(modified_inpainted_image, modified_clean_background)`。
    *   `before_rendering(self, image_to_render_on, translated_texts, bubble_coords, bubble_styles, params)`: 在文本渲染到图像上前。可修改用于渲染的基础图像、待渲染文本、气泡坐标或气泡样式。返回 `(modified_image, modified_texts, modified_coords, modified_styles)`。
    *   `after_processing(self, final_image, results_dict, params)`: 在所有处理完成，返回最终结果前。可修改最终输出的图像和包含所有中间结果的 `results_dict`。返回 `(modified_final_image, modified_results_dict)`。

*   **通知型钩子 (这些钩子通常不修改数据，返回 `None`):**
    *   `on_enable(self)`: 当插件被启用时调用。
    *   `on_disable(self)`: 当插件被禁用时调用。
    *   `before_ocr(self, image_pil, bubble_coords, params)`: 在 OCR 过程开始前调用。
    *   `before_inpainting(self, image_pil, bubble_coords, params)`: 在背景修复/填充过程开始前调用。

**重要提示：** 在任何钩子方法的实现开始处，都应该首先检查插件是否已启用 (`if not self.is_enabled(): return None`)，以确保禁用的插件不会执行其逻辑。

#### 10.6 添加用户配置

如果你的插件需要用户可调整的设置，可以通过在插件类中实现 `get_config_spec(self)` 方法来声明这些配置项。

*   **配置规范结构:** `get_config_spec()` 方法应返回一个列表 (list)，列表中的每个元素都是一个字典 (dict)，用于描述一个独立的配置项。
*   **配置项字典的键:**
    *   `name` (str, 必需): 配置项的内部唯一名称。你在插件代码中将使用这个名称通过 `self.config.get(name, default_value)` 来获取配置值。
    *   `label` (str, 必需): 在插件管理界面的配置表单中显示给用户的标签文本。
    *   `type` (str, 必需): 指定配置项的输入类型。支持的类型包括：
        *   `'text'`: 普通文本输入框。
        *   `'number'`: 数字输入框 (插件管理器会尝试转换为 `int` 或 `float`)。
        *   `'boolean'`: 复选框 (checkbox)。
        *   `'select'`: 下拉选择框。
    *   `default` (any, 必需): 该配置项的默认值。当用户首次使用插件或未设置该项时，将使用此默认值。确保默认值与 `type` 匹配（例如，`boolean` 类型的默认值应为 `True` 或 `False`）。
    *   `description` (str, 可选): 对配置项的简短描述或提示信息，会显示在配置表单中对应项的下方。
    *   `options` (list[str], 可选): 仅当 `type` 为 `'select'` 时需要。提供一个字符串列表，作为下拉选择框的选项。

*   **配置的加载与访问:**
    *   插件管理器负责从 `config/plugin_configs/你的插件名.json` 文件中读取用户保存的配置。
    *   这些配置数据会传递给你插件的 `load_config(self, config_data)` 方法。`PluginBase` 的 `load_config` 方法会将加载的 `config_data` 与你在 `get_config_spec` 中定义的默认值进行合并，并将最终结果存储在插件实例的 `self.config` 字典中。
    *   因此，在你的插件代码中（例如钩子方法中），你可以通过 `self.config.get('配置项名称', '后备默认值')` 来安全地获取配置项的值。
    *   如果你需要在配置加载后执行一些特定的初始化逻辑（例如根据配置值设置日志级别），可以覆盖 `load_config` 方法，但在覆盖的方法中**务必调用 `super().load_config(config_data)`** 以确保 `self.config` 被正确填充。

*   **UI 显示:** 插件管理器会读取 `get_config_spec()` 的返回结果，并在前端的插件管理模态框中为你的插件动态生成一个配置表单。用户修改并保存后，会调用后端的插件配置保存 API，更新对应的 JSON 文件，并通知插件管理器重新加载该插件的配置。

#### 10.7 访问应用和管理器

在插件实例化时，插件管理器会将自身 (`plugin_manager`) 和 Flask 应用实例 (`app`) 作为参数传递给插件的构造函数。插件应将它们保存为实例属性以便后续使用。

*   **`self.plugin_manager`**:
    *   **获取其他插件:** `plugin = self.plugin_manager.get_plugin("其他插件名")`。这允许插件之间进行有限的交互（例如，一个插件调用另一个已启用插件提供的公共方法），但需谨慎设计以避免强耦合。
    *   **触发钩子 (不推荐):** 理论上可以通过 `self.plugin_manager.trigger_hook(...)` 触发其他钩子，但这通常不推荐，因为它可能导致复杂的控制流和潜在的循环触发。插件主要应通过实现自己的钩子方法来响应事件。
    *   **访问管理器功能:** 将来如果插件管理器提供其他公共服务（例如，共享数据存储），插件可以通过此引用访问。
*   **`self.app`**:
    *   **访问 Flask 上下文:** 如果插件需要在 Flask 的请求上下文中执行操作（例如访问 `current_app`, `g`, `request` 对象），可以通过 `self.app` (通常是 `with self.app.app_context(): ...`) 来获取应用上下文。
    *   **注册路由/蓝图 (高级，需谨慎):** 插件理论上可以尝试使用 `self.app.register_blueprint(...)` 或 `self.app.add_url_rule(...)` 来添加自己的 API 端点或页面。然而，这需要非常小心地处理路由冲突，并且可能与主应用的蓝图结构和 URL 前缀不完全兼容。如果插件确实需要提供自己的 API，建议：
        1.  确保路由唯一。
        2.  考虑为插件的 API 使用特定的前缀。
        3.  这种动态添加路由的方式可能在某些 Flask 部署场景下（如使用 uWSGI 的 lazy-apps）遇到问题。
    *   **访问应用配置:** `config_value = self.app.config.get('MY_APP_CONFIG_KEY')`。
*   **`self.logger`**:
    *   每个插件实例都会自动获得一个由 `PluginBase` 初始化的 Python `logging.Logger` 实例，其名称格式为 `Plugin.你的插件名` (例如 `Plugin.我的自定义滤镜`)。
    *   插件应使用 `self.logger.info()`, `self.logger.debug()`, `self.logger.warning()`, `self.logger.error()` 来记录其自身的日志信息。这些日志会根据 `app.py` 中配置的全局日志系统进行处理（输出到控制台和文件）。

#### 10.8 插件加载与启用/禁用 (包括默认状态)

1.  **加载阶段 (应用启动时):**
    *   `PluginManager` 会扫描所有已配置的插件目录（默认为 `src/plugins/` 和项目根目录下的 `plugins/`）。
    *   对于每个发现的潜在插件包（包含 `__init__.py` 和 `plugin.py` 的文件夹），管理器会尝试动态导入其 `plugin.py` 模块。
    *   在模块中查找第一个继承自 `PluginBase` 的类。
    *   实例化该插件类，并将插件管理器自身 (`self`) 和 Flask 应用实例 (`self.app`) 传递给插件的构造函数。
    *   调用插件实例的 `setup()` 方法。如果 `setup()` 返回 `False`，则插件加载失败，后续步骤将被跳过。
    *   如果 `setup()` 成功，插件实例会被存储在管理器的 `self.plugins` 字典中（键为插件的 `plugin_name`）。
    *   插件的元数据（通过 `get_metadata()` 获取）会被存储在 `self.plugin_metadata` 中。
    *   插件的配置会从 `config/plugin_configs/插件名.json` 文件加载，并传递给插件的 `load_config()` 方法。
    *   管理器会检查插件类中是否实现了已定义的钩子方法，并将实现的钩子注册到对应的钩子点列表。
2.  **默认启用状态确定:**
    *   **用户偏好优先:** `PluginManager` 首先会检查 `config/plugin_default_states.json` 文件。如果该文件中存在当前插件名称的条目（例如 `{"我的自定义滤镜": false}`），则该值（`true` 或 `false`）将作为此插件的默认启用状态。
    *   **插件自身定义:** 如果在 `plugin_default_states.json` 中找不到该插件的条目（通常发生在插件首次被发现时），管理器会采纳插件类中定义的 `plugin_enabled_by_default` 属性值（`True` 或 `False`）作为其默认启用状态。
    *   **持久化新插件的默认状态:** 当一个新插件的默认状态是基于其 `plugin_enabled_by_default` 确定时，管理器会将这个状态（插件名和布尔值）添加到 `self.plugin_default_states` 字典中，并在所有插件加载完成后将整个字典保存回 `plugin_default_states.json` 文件。
3.  **启动时启用/禁用:**
    *   在所有插件都完成上述加载步骤后，`PluginManager` 会遍历所有已成功加载的插件。
    *   对于每个插件，它会根据第2步中确定的最终默认启用状态，调用插件实例的 `enable()` 或 `disable()` 方法。`enable()` 方法会将插件内部的 `_enabled` 标记设为 `True` 并调用 `on_enable()` 钩子；`disable()` 则设为 `False` 并调用 `on_disable()`。
4.  **运行时启用/禁用 (通过 UI):**
    *   用户可以通过插件管理界面的开关来实时启用或禁用某个插件。
    *   这个操作会调用插件实例的 `enable()` 或 `disable()` 方法，改变其运行时的 `_enabled` 状态。
    *   **重要：** 运行时的启用/禁用状态是临时的，仅在当前应用运行期间有效。它**不会**修改 `config/plugin_default_states.json` 文件中为该插件持久化的用户默认偏好。下次应用重启时，插件仍会根据持久化的默认状态来决定初始是否启用。
    *   插件在其钩子方法的实现中，应始终通过调用 `if not self.is_enabled(): return None` 来检查自身是否处于启用状态，然后再执行其核心逻辑。
5.  **修改默认启用状态 (通过 UI):**
    *   插件管理界面还提供了单独的“默认启用”复选框。当用户修改此复选框的状态时，前端会调用后端的 `/api/plugins/<plugin_name>/set_default_state` API。
    *   该 API 会更新 `PluginManager` 中的 `self.plugin_default_states` 字典，并立即调用 `self.save_plugin_default_states()` 将更改持久化到 `config/plugin_default_states.json` 文件。这个更改会在下次应用启动时生效。

#### 10.9 示例插件参考

为了更好地理解如何编写插件，建议参考项目中可能存在的示例插件。如果项目提供了 `src/plugins/example_plugin/` 这样的目录，其中通常会包含一个简单的插件实现，展示了如何定义元数据、实现 `setup()` 方法、响应一个或多个钩子，以及如何声明和使用配置项。

分析示例插件的 `plugin.py` 文件，可以帮助你：

*   理解 `PluginBase` 的继承和元数据声明格式。
*   学习如何在 `setup()` 中进行初始化。
*   观察钩子方法的正确签名和返回值约定。
*   了解如何通过 `self.config` 访问由 `get_config_spec()` 定义的配置项。
*   查看如何使用 `self.logger` 进行日志记录。

如果没有现成的示例插件，上面 10.4 节中提供的 `MyCustomFilterPlugin` 代码片段可以作为一个基础模板。

#### 10.10 调试插件

调试插件时，可以采用以下方法：

*   **日志记录:** 在插件的关键代码路径（如 `setup`, `on_enable`, `on_disable`, 以及所有实现的钩子方法中）使用 `self.logger.info()`, `self.logger.debug()`, `self.logger.warning()`, `self.logger.error()` 添加详细的日志输出。可以通过调整 `app.py` 中对插件日志记录器（如 `logging.getLogger(f"Plugin.{self.plugin_name}")`）的日志级别来控制输出的详细程度。检查主应用的日志文件（位于 `logs/` 目录）和控制台输出，查看插件的加载情况、钩子是否被触发、配置是否正确加载以及执行过程中的任何错误。
*   **Python 调试器:** 如果你使用支持 Python 调试的 IDE (如 VS Code, PyCharm)，可以在插件的 `.py` 文件中设置断点。当插件管理器加载插件或触发其钩子时，执行应该会在断点处暂停，允许你检查变量状态和单步执行代码。确保你的 Flask 应用是以非生产模式（例如，直接运行 `python app.py` 而不是通过 Gunicorn 等）启动，以便调试器能正常工作。
*   **检查插件加载状态:** 应用启动后，可以通过访问 `/api/plugins` API 端点（例如在浏览器中或使用 Postman）来查看所有已加载插件的列表及其元数据和当前启用状态。这可以帮助确认你的插件是否被插件管理器正确发现和加载。
*   **检查插件配置:**
    *   确认你的插件的 `get_config_spec()` 方法是否正确声明了所有配置项。
    *   在插件管理界面检查为你的插件生成的配置表单是否符合预期。
    *   修改并保存配置后，检查 `config/plugin_configs/你的插件名.json` 文件是否已创建或更新，并且内容是否正确。
    *   在插件的 `load_config()` 方法或使用配置的地方打印 `self.config` 的内容，确认配置值是否按预期加载。
*   **隔离测试:** 如果怀疑插件与其他插件或核心功能存在冲突，可以尝试在插件管理界面中禁用其他所有插件，只启用你正在调试的插件，然后重现问题。这有助于缩小问题范围。
*   **钩子参数与返回值:** 仔细检查你的钩子方法的参数签名是否与 `PluginBase` 中的定义完全一致。同时，确认数据修改型钩子是否按预期返回了包含修改后数据的元组。不正确的签名或返回值可能导致钩子不被正确调用或数据未按预期传递。
*   **模拟触发 (高级):** 在开发阶段，你甚至可以编写一个小的独立 Python 脚本，在其中实例化你的插件和（一个简化的）插件管理器，然后手动调用 `manager.trigger_hook()` 来测试特定钩子的行为，传入模拟的数据。

### 11. 打包与部署

项目使用 PyInstaller 进行打包，相关的配置信息通常定义在项目根目录下的 `app.spec` 文件中。

*   **核心配置 (`app.spec`):**
    *   **`Analysis` 部分:**
        *   `pathex`: 指定 PyInstaller 搜索模块的路径列表。通常应包含项目根目录。
        *   `hiddenimports`: 一个非常重要的列表，用于指定那些被动态导入或者 PyInstaller 静态分析未能自动发现的 Python 模块。常见的需要添加到这里的库包括：
            *   与 PyTorch, PaddlePaddle, OpenCV, Pillow, NumPy 等相关的底层依赖或特定子模块。
            *   某些 Flask 扩展。
            *   插件可能动态导入的模块。
            *   `engineio.async_drivers.threading` (如果 Flask-SocketIO 使用 eventlet/gevent，可能需要对应的驱动)。
            *   特定操作系统下可能需要的库。
        *   `hookspath`: 如果项目使用了 PyInstaller hooks (用于更复杂依赖的自定义脚本)，在这里指定 hooks 目录的路径。
    *   **`datas` 列表 (在 `a = Analysis(...)` 之后，`pyz = PYZ(...)` 之前):** 这是将非 Python 文件和整个目录复制到打包后应用中的关键部分。**必须确保所有运行时需要的资源都包含在这里。**
        *   **格式:** `('源文件或目录路径', '在打包后应用内的目标路径')`
        *   **必须包含的示例:**
            *   `('config', 'config')`  # 整个 config 目录
            *   `('models/paddle_ocr', 'models/paddle_ocr')` # PaddleOCR 模型 (如果预下载)
            *   `('weights', 'weights')` # YOLOv5 权重
            *   `('manga_ocr_model', 'manga_ocr_model')` # MangaOCR 模型
            *   `('src/app/static', 'src/app/static')` # 所有静态资源
            *   `('src/app/templates', 'src/app/templates')` # HTML 模板
            *   `('sd-webui-cleaner', 'sd-webui-cleaner')` # LAMA 相关库和模型
            *   `('ultralytics_yolov5_master', 'ultralytics_yolov5_master')` # YOLOv5 代码库
            *   **插件目录:**
                *   `('src/plugins', 'src/plugins')` # 内置插件
                *   `('plugins', 'plugins')` # 用户自定义插件 (如果放在根目录)
        *   **注意目标路径:** 目标路径是相对于打包后可执行文件所在目录的。
    *   **`COLLECT` 和 `EXE` 部分:** 定义最终可执行文件的构建方式，例如是否为单文件 (`onefile`) 或单目录 (`onedir`)，是否包含控制台窗口 (`console=True/False`)，以及图标等。对于包含大量数据文件的应用，`onedir` 模式通常启动更快且更稳定。
*   **用户数据目录:**
    *   在 `app.py` 中，`TEMP_FOLDER_PATH` 和 `UPLOAD_FOLDER_PATH` (位于 `data/temp` 和 `data/uploads`)，以及 `logs/` 目录和 `data/sessions/` 目录是由 `resource_path()` 和 `os.makedirs()` 在应用启动时动态创建的。这意味着这些目录会创建在可执行文件旁边（对于 `onedir` 包）或解压后的临时目录中（对于 `onefile` 包）。
    *   这些用户数据目录**不应该**被包含在 `app.spec` 的 `datas` 列表中，因为它们是运行时生成的。
*   **第三方库的特殊处理:**
    *   **PaddleOCR 和 LAMA (sd-webui-cleaner):** 这些库可能依赖特定的 DLL (Windows) 或 SO (Linux) 文件，或者有复杂的内部资源加载机制。确保 PyInstaller 能找到所有相关的动态链接库。有时可能需要在 `pathex` 中添加这些库的安装路径，或者手动将缺失的 DLL/SO 文件复制到打包后的目录中。`sd-webui-cleaner` 作为一个完整的代码库被包含，其内部的模型和配置文件也需要通过 `datas` 正确复制。
    *   **Torch/CUDA:** 如果使用 GPU 版本的 PyTorch，打包 CUDA 相关的 DLL/SO 文件会非常复杂，并且通常会导致包体积巨大且可移植性差。**对于分发，通常建议要么只打包 CPU 版本，要么指导用户自行安装 CUDA 和 GPU 驱动。** 如果确实要尝试打包 GPU 支持，需要深入研究 PyInstaller 和 PyTorch 关于 CUDA 打包的文档。
*   **打包命令:**
    *   首先，如果还没有 `app.spec` 文件，可以通过运行 `pyi-makespec app.py [其他选项]` 来生成一个基础的 spec 文件。
    *   然后，仔细编辑 `app.spec` 文件，特别是 `hiddenimports` 和 `datas` 部分。
    *   最后，使用 `pyinstaller app.spec` 命令进行打包。
    *   常用选项：
        *   `--noconfirm`: 打包前不要求确认覆盖。
        *   `--clean`: 打包前清理旧的构建文件。
        *   `--onefile` 或 `--onedir`: 选择打包模式。
        *   `--windowed` 或 `--noconsole`: 无控制台窗口 (GUI 应用)。
        *   `--icon=src/app/static/pic/favicon.ico`: 指定应用图标。
*   **测试打包结果:**
    *   打包完成后，在**一个没有安装 Python 开发环境和项目依赖的干净的测试机器上**运行生成的可执行文件 (通常在 `dist/应用名/` 目录下)。
    *   全面测试应用的所有功能，包括图片上传、所有 OCR 和翻译选项、修复、编辑、会话管理、插件（如果打包了的话）等。
    *   检查应用是否能正确创建和读写 `data/` 和 `logs/` 目录。
    *   检查是否有任何资源文件（图片、字体、模型）加载失败的错误（通常会在控制台或日志中看到）。

### 12. 维护与功能扩展指南

*   **代码风格与质量:**
    *   **遵循 PEP 8:** 保持 Python 代码风格的一致性，使用 linter (如 Flake8, Pylint) 和 formatter (如 Black, autoPEP8) 可以帮助自动化这个过程。
    *   **清晰命名:** 为变量、函数、类使用清晰且有意义的名称。
    *   **模块化设计:** 保持现有良好的模块化结构。新功能如果逻辑复杂或独立，应考虑创建新的模块或类。
    *   **函数/方法职责单一:** 每个函数或方法应专注于完成一个明确的任务。
    *   **注释与文档字符串:** 为复杂的代码段添加必要的注释。为所有公共模块、类、函数和方法编写清晰的文档字符串 (docstrings)，解释其用途、参数和返回值。
*   **版本控制 (Git):**
    *   **频繁提交:** 将相关的更改作为一个逻辑单元进行提交。
    *   **有意义的提交信息:** 编写清晰的提交信息，描述本次提交的目的和主要更改内容。
    *   **分支策略:** 对于新功能开发或较大的重构，使用特性分支 (feature branches)，完成后通过 Pull Request (或 Merge Request) 合并回主分支 (如 `main` 或 `develop`)。鼓励代码审查。
    *   **标签 (Tags):** 为重要的发布版本打上标签 (e.g., `v1.0.0`, `v1.1.0`)。
*   **依赖管理:**
    *   **`requirements.txt`:** 始终保持此文件的更新。当添加新的 Python 依赖或更新现有依赖版本后，及时更新 `requirements.txt` (例如，通过 `pip freeze > requirements.txt`)。
    *   **定期检查更新:** 关注核心依赖库（Flask, PyTorch, Pillow, OpenCV, requests, openai SDK 等）的更新日志，了解是否有安全修复、性能改进或新功能。
    *   **兼容性测试:** 在升级依赖库版本后，务必进行全面的功能测试，以确保新版本与项目代码兼容，没有引入破坏性更改。
*   **模块化优先:**
    *   当计划添加新功能时，首先评估该功能是否可以作为一个独立的插件来实现。插件系统是扩展应用功能、保持核心代码简洁和稳定的首选方式。
    *   如果新功能确实需要修改核心模块（`src/core/`, `src/interfaces/`），则应仔细考虑其对现有逻辑的影响，并确保修改是模块化的，易于理解和维护。
*   **API 设计:**
    *   如果需要添加新的后端 API 端点，应遵循项目现有的 API 设计风格（例如，使用 Flask 蓝图，保持 RESTful 原则）。
    *   **版本控制:** 对于公开的 API，如果发生不兼容的更改，应考虑引入 API 版本控制（例如，`/api/v2/...`）。对于内部使用的 API，也应谨慎修改，避免破坏前端调用。
    *   **向后兼容:** 尽可能保持向后兼容性，例如像 `app.py` 中那样为旧 API 路径添加重定向。
*   **会话数据结构:**
    *   在修改会话中存储的数据结构（即 `session_data` 对象的格式）时要非常小心。
    *   如果添加了新的需要保存的 UI 设置或图片状态，确保 `session.js` 中的 `collectCurrentSessionData` 和 `handleLoadSession` 函数，以及后端 `session_manager.py` 中的 `save_session` 和 `load_session` 函数都已更新以正确处理这些新字段。
    *   如果对现有字段的结构或含义进行了不兼容的更改，需要考虑如何处理旧版本会话数据的加载。可能的策略包括：
        *   **版本标记:** 在会话元数据中添加一个版本号。加载时根据版本号执行不同的转换逻辑。
        *   **迁移脚本:** 提供一个单独的脚本或工具，用于将旧版本的会话文件升级到新格式。
        *   **声明不兼容:** 明确告知用户新版本应用不兼容旧版本的会话数据。
*   **错误处理与日志:**
    *   对所有可能发生异常的操作（如文件读写、网络请求、外部库调用、模型加载、数据转换等）使用 `try...except`块进行健壮的错误处理。
    *   记录有意义的错误信息到日志中，包括相关的上下文信息和可能的堆栈跟踪，以便于问题定位。
    *   在前端，向用户提供清晰、友好的错误提示，而不是直接暴露底层技术细节。
*   **前端性能:**
    *   对于涉及大量图片处理或复杂 DOM 操作的前端功能（如实时编辑、大量缩略图渲染、手动标注交互），需要关注性能。
    *   **避免不必要的 DOM 重绘/回流:** 批量更新 DOM，使用 DocumentFragment，合理使用 CSS 过渡和动画。
    *   **节流 (Throttling) 和防抖 (Debouncing):** 对高频触发的事件（如鼠标移动、窗口大小调整、输入框输入）的处理函数使用节流或防抖技术，以减少计算量和 UI 更新频率（例如，项目中对气泡位置/旋转调整的预览渲染就使用了 `setTimeout` 实现延迟/节流）。
    *   **懒加载/虚拟滚动:** 如果图片列表或气泡列表非常长，可以考虑实现懒加载或虚拟滚动技术来提高初始加载速度和渲染性能。
    *   **代码分割/按需加载 (高级):** 对于大型前端应用，可以考虑使用 Webpack 或类似工具进行代码分割，实现 JavaScript 模块的按需加载。
*   **安全性:**
    *   **API Key 处理:** (已在 3.4 节强调) 避免将 API 密钥硬编码在代码中或提交到版本控制。前端应在运行时从用户输入获取，后端仅在需要时接收和使用，不应持久化存储用户的 API 密钥（除非是用户明确配置在后端文件且文件受保护）。
    *   **输入验证:** 对所有来自用户或外部 API 的输入进行严格的验证和清理，防止注入攻击（如 XSS，尽管对于桌面类应用风险较低，但良好习惯总是好的）或意外的程序行为。例如，检查文件类型、大小，清理文本输入中的潜在恶意脚本。
    *   **文件路径处理:** 在处理用户提供的文件名或路径时，要特别小心，防止路径遍历攻击。`path_helpers.py` 中的实现看起来是安全的，因为它通常是基于预定义的相对路径和 `resource_path`。
    *   **依赖库安全:** 定期检查项目使用的第三方库是否存在已知的安全漏洞，并及时更新到安全版本。

### 13. 故障排查

当应用出现问题时，可以按照以下步骤进行排查：

1.  **后端日志:**
    *   **首要步骤。** 检查项目根目录下 `logs/` 目录中最新生成的日志文件 (例如 `comic_translator_YYYY-MM-DD.log`)。
    *   日志中通常会包含详细的错误信息、异常类型、发生错误的代码位置（堆栈跟踪）以及相关的上下文信息。
    *   注意日志级别，`ERROR` 和 `CRITICAL` 级别的日志通常指示了严重问题。`WARNING` 级别的日志可能提示潜在问题或非致命错误。`INFO` 和 `DEBUG` 级别的日志可以帮助理解程序的执行流程。
2.  **Flask 控制台输出:**
    *   在通过 `python app.py` 运行应用时，Flask (Werkzeug) 的控制台输出是排查启动阶段错误、HTTP 请求处理错误（如 404 Not Found, 500 Internal Server Error）的重要来源。
    *   `app.py` 中配置的自定义日志也会同时输出到控制台（如果配置了控制台处理器）。
3.  **浏览器开发者工具 (通常按 F12 打开):**
    *   **控制台 (Console) 标签页:**
        *   检查是否有 JavaScript 运行时错误。错误信息通常会指出发生错误的文件名和行号。
        *   查看通过 `console.log()`, `console.warn()`, `console.error()` 输出的调试信息。
    *   **网络 (Network) 标签页:**
        *   监控前端与后端之间的所有 HTTP 请求。
        *   **检查 API 请求状态:** 确认对 `/api/...` 端点的请求是否成功返回 (HTTP 状态码 200 OK)。
        *   如果请求失败 (例如状态码 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 500 Internal Server Error)，点击该请求查看其 "Response" 或 "Preview" 标签页，后端通常会在响应体中返回更具体的 JSON 格式错误信息 (例如 `{"error": "详细错误描述"}`)。
        *   检查请求的 "Headers" 和 "Payload" (或 "Request Body") 是否与预期一致。
        *   检查静态资源（CSS, JS, 图片, 字体）是否成功加载。
4.  **UI 连接测试按钮:**
    *   在前端界面的设置面板中，为多个外部服务（Ollama, Sakura, LAMA, 百度OCR/翻译, AI视觉OCR, 有道翻译）都提供了 "测试连接" 按钮。
    *   使用这些按钮可以快速验证与这些服务的网络连通性以及 API 密钥（如果需要）的有效性。测试结果会通过 `ui.showGeneralMessage` 显示。
5.  **模型文件检查:**
    *   确认所有 AI 模型文件（YOLOv5 权重 `.pt`，MangaOCR 模型文件夹，LAMA 模型 `.safetensors`，PaddleOCR 模型文件夹）是否已按照第 3.3 节 "模型下载/放置" 中的要求，正确放置在项目结构中指定的目录内。
    *   检查文件名是否准确无误，路径是否正确。
    *   模型文件损坏或不完整也可能导致加载失败。
6.  **API 密钥检查:**
    *   对于需要 API Key 的云服务，再次确认在前端界面输入的所有 API Key (或 App ID/Secret Key) 是否准确无误、没有多余的空格，并且是有效的。
    *   检查对应云服务提供商的账户状态，确保 API Key 未过期、账户有足够的调用配额或余额。
7.  **依赖库版本与兼容性:**
    *   检查项目中安装的关键 Python 依赖库（如 PyTorch, PaddlePaddle, OpenCV-Python, Pillow, `openai` SDK, `requests` 等）的版本。
    *   如果最近更新过某个库，或者在不同环境中使用，版本不兼容可能是导致问题的原因。可以尝试回退到之前已知可工作的版本，或查阅库的更新日志看是否有破坏性更改。
    *   确保虚拟环境已正确激活，并且使用的是该虚拟环境中的 Python 解释器和库。
8.  **插件相关问题:**
    *   如果某个功能在启用特定插件后出现问题，或者某个插件无法按预期工作：
        *   尝试在插件管理界面中**禁用该插件**，然后重试相关功能，看问题是否消失。这有助于判断问题是否由该插件引起。
        *   检查该插件的日志输出（如果插件作者为其配置了独立的 logger，或者在主日志中筛选与该插件相关的条目）。
        *   如果插件有用户配置项，检查其配置是否正确。可以在 `config/plugin_configs/插件名.json` 文件中查看实际保存的配置。
        *   检查插件的 `setup()` 方法是否成功执行（通常会在日志中有所体现）。
9.  **会话管理问题:**
    *   **加载会话失败:**
        *   检查 `data/sessions/会话名/session_meta.json` 文件是否存在，并且其内容是否为有效的 JSON 格式。可以使用在线 JSON 校验工具检查。
        *   检查 `session_meta.json` 中记录的图片元数据，并确认对应的 `.b64` 图像数据文件（如 `image_0_original.b64`）是否存在于同一目录下，且未损坏。
    *   **保存会话失败:** 查看后端日志，通常会有关于文件写入权限或 JSON 序列化错误的详细信息。
10. **手动标注/编辑模式问题:**
    *   **坐标不准确/行为怪异:**
        *   首先检查浏览器控制台是否有 JavaScript 错误。
        *   在 `ui.js` 的 `calculateImageDisplayMetrics` 函数中添加 `console.log`，打印计算出的图片显示指标（缩放比例、偏移量等），确认它们是否与视觉观察一致。这是坐标转换（屏幕坐标 <=> 图像原生坐标）的基础。
        *   在 `labeling_mode.js` 或 `edit_mode.js` 中处理鼠标事件和坐标转换的地方添加日志，打印转换前后的坐标值，进行对比。
    *   **无法选择/拖动/缩放框:** 检查事件是否正确绑定 (`events.js`)，以及相关的状态变量（如 `isDragging`, `isResizing`, `selectedManualBoxIndex`）是否按预期更新 (`state.js`)。
    *   **样式未应用/预览不正确:** 检查 `edit_mode.js` 中 `reRenderFullImage` 或 `renderBubblePreview` 函数的参数传递是否正确，以及后端 `/api/re_render_image` 或 `/api/re_render_single_bubble` 的响应是否符合预期。
11. **打包后应用程序的问题:**
    *   **启动失败或功能缺失:** 最常见的原因是资源文件（模型、`src/app/static/` 目录下的静态文件、`src/app/templates/` 目录下的 HTML 模板、DLL/SO 文件等）未能正确包含在最终的打包结果中。
        *   仔细检查并修改项目根目录下的 `app.spec` 文件，特别是 `datas` 列表和 `hiddenimports` 列表。确保所有运行时需要的非 Python 文件和目录都已通过 `datas` 添加，并且目标路径正确。
        *   对于 PyInstaller 未能自动发现的 Python 模块，将它们添加到 `hiddenimports`。
    *   **在打包后的程序所在目录打开命令行/终端，然后直接运行可执行文件。** 这样如果程序在启动或运行过程中发生崩溃或错误，相关的错误信息通常会直接输出到该命令行窗口，便于定位问题。
    *   **路径问题:** 打包后，程序内部对文件路径的引用方式可能需要调整。`path_helpers.py` 中的 `resource_path()` 函数就是为了解决这个问题而设计的，确保所有对资源文件的访问都通过它。
    *   **权限问题:** 某些操作系统或环境可能对打包后的程序读写文件的权限有限制，例如写入 `data/` 或 `logs/` 目录。
12. **新增功能的特定排查点：**
    *   **RPD 设置：** 如果翻译或 AI 视觉 OCR 调用非常缓慢或频繁失败（特别是对于云服务），检查前端设置的 RPD 值是否过低，或者服务提供商本身是否有更严格的未声明的频率限制。查看后端日志中关于 RPD 限制的等待信息。
    *   **JSON 格式提示词：** 如果启用了 JSON 格式输出但大语言模型未按预期返回结构化的 JSON，首先确认所选的模型是否良好支持 JSON 输出模式（某些模型可能需要特定的微调或更强的引导）。其次，检查发送给模型的提示词（`constants.py` 或用户自定义的）是否清晰地要求了 JSON 格式，并提供了正确的 JSON 结构示例。查看后端日志中模型返回的原始响应。
    *   **自定义 OpenAI Base URL：** 如果使用自定义的 OpenAI 兼容服务失败，确认：
        *   前端输入的 Base URL 格式正确（例如，对于很多兼容服务，它应该以 `/v1` 结尾）。
        *   API Key 是否对该自定义服务有效。
        *   目标服务确实与 OpenAI 的 Chat Completions API 兼容。
        *   网络是否能正常访问该 Base URL。
    *   **独立气泡填充色：** 如果在编辑模式下设置的单个气泡的独立填充颜色在重渲染后未按预期显示：
        *   检查 `edit_mode.js` 中 `reRenderFullImage` 函数的逻辑，确认它是否正确地从 `state.bubbleSettings` 中获取了每个气泡的 `fillColor`。
        *   确认在调用该函数前，`state.bubbleSettings` 中对应气泡的 `fillColor` 是否已被正确更新。
        *   查看前端构造并发送给后端 `/api/re_render_image` 的 `all_bubble_styles` 参数中，是否包含了正确的填充色信息（尽管当前后端逻辑似乎不直接使用这个颜色进行填充，而是依赖前端预填充的背景）。
        *   确认前端预填充背景的 Canvas 操作是否成功，并且生成的 `preFilledBackgroundBase64` 是否包含了正确的独立颜色。

通过系统地检查这些方面，应该能够定位和解决大部分遇到的问题。

