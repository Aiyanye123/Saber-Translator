**4.1. 更新核心处理流程 (`src/core/processing.py`)**

*   **文件路径:** `src/core/processing.py`
*   **修改内容:**
    1.  在 `process_image_translation` 函数的参数列表中添加 `custom_ai_vision_base_url=None`。
    2.  在调用 `recognize_text_in_bubbles` 函数时，如果 `ocr_engine` 是 `constants.AI_VISION_OCR_ENGINE_ID`，则将 `custom_ai_vision_base_url` 参数传递给它。

*   **代码演示:**

    ```python
    # src/core/processing.py
    
    # ... (其他 import)
    from src.core.ocr import recognize_text_in_bubbles # 确保导入
    from src.shared import constants # 确保导入常量
    
    logger = logging.getLogger("CoreProcessing")
    
    def process_image_translation(
        image_pil,
        target_language=constants.DEFAULT_TARGET_LANG,
        source_language=constants.DEFAULT_SOURCE_LANG,
        # ... (大量现有参数保持不变) ...
        ocr_engine='auto',
        baidu_api_key=None,
        baidu_secret_key=None,
        baidu_version='standard',
        ai_vision_provider=None,
        ai_vision_api_key=None,
        ai_vision_model_name=None,
        ai_vision_ocr_prompt=None,
        # VVVVVV 新增参数 VVVVVV
        custom_ai_vision_base_url=None, # 用于AI视觉OCR的自定义Base URL
        # ^^^^^^ 结束新增 ^^^^^^
        use_json_format_translation=False,
        use_json_format_ai_vision_ocr=False,
        custom_base_url=None, # 这个是用于翻译服务的自定义Base URL
        rpd_limit_translation: int = constants.DEFAULT_RPD_TRANSLATION,
        rpd_limit_ai_vision_ocr: int = constants.DEFAULT_RPD_AI_VISION_OCR
    ):
        # ... (函数开头的日志和初始化代码) ...
    
        try:
            # ... (步骤1: 检测气泡坐标，包括 provided_coords 的处理和 AFTER_DETECTION 钩子) ...
    
            original_texts = []
            if not skip_ocr:
                # ... (BEFORE_OCR 钩子) ...
                logger.info("步骤 2: OCR 识别文本...")
                start_time = time.time()
    
                if ocr_engine == constants.AI_VISION_OCR_ENGINE_ID: # 使用常量
                    logger.info(f"使用AI视觉OCR ({ai_vision_provider}/{ai_vision_model_name}) 识别文本...")
                    original_texts = recognize_text_in_bubbles(
                        image_pil,
                        bubble_coords,
                        source_language,
                        ocr_engine, # 传递 ocr_engine
                        ai_vision_provider=ai_vision_provider,
                        ai_vision_api_key=ai_vision_api_key,
                        ai_vision_model_name=ai_vision_model_name,
                        ai_vision_ocr_prompt=ai_vision_ocr_prompt,
                        # VVVVVV 新增传递 custom_ai_vision_base_url VVVVVV
                        custom_ai_vision_base_url=custom_ai_vision_base_url,
                        # ^^^^^^ 结束新增 ^^^^^^
                        use_json_format_for_ai_vision=use_json_format_ai_vision_ocr,
                        rpd_limit_ai_vision=rpd_limit_ai_vision_ocr
                    )
                elif ocr_engine == 'baidu_ocr':
                     original_texts = recognize_text_in_bubbles(
                        image_pil,
                        bubble_coords,
                        source_language,
                        ocr_engine,
                        baidu_api_key=baidu_api_key,
                        baidu_secret_key=baidu_secret_key,
                        baidu_version=baidu_version
                        # 注意：这里不需要 custom_ai_vision_base_url
                    )
                else:
                    # MangaOCR 或 PaddleOCR
                    original_texts = recognize_text_in_bubbles(
                        image_pil, bubble_coords, source_language, ocr_engine
                        # 注意：这里不需要 custom_ai_vision_base_url
                    )
    
                logger.info(f"OCR 完成 (耗时: {time.time() - start_time:.2f}s)")
                # ... (AFTER_OCR 钩子) ...
            else:
                logger.info("步骤 2: 跳过 OCR。")
                original_texts = [""] * len(bubble_coords)
    
            # ... (步骤3: 翻译文本, 步骤4: 修复/填充背景, 步骤5: 渲染文本, 步骤6: 准备最终结果) ...
            # ... (所有钩子调用) ...
    
            return (
                processed_image, # 假设 processed_image 是最终结果
                original_texts,
                translated_bubble_texts, # 假设已定义
                translated_textbox_texts, # 假设已定义
                bubble_coords,
                initial_bubble_styles # 假设已定义
            )
    
        except Exception as e:
            # ... (错误处理) ...
            return original_image_copy, [], [], [], [], {} # 确保返回类型一致
    
    # ... (文件底部的测试代码) ...
    ```

---

**4.2. 更新核心 OCR 逻辑 (`src/core/ocr.py`)**

*   **文件路径:** `src/core/ocr.py`
*   **修改内容:**
    1.  在 `recognize_text_in_bubbles` 函数的参数列表中添加 `custom_ai_vision_base_url=None`。
    2.  当 `ocr_engine_type` 为 `'AIVision'` 时：
        *   增加一个检查：如果 `ai_vision_provider` 是 `constants.CUSTOM_AI_VISION_PROVIDER_ID` 但 `custom_ai_vision_base_url` 未提供，则记录错误并提前返回空结果列表。
        *   在循环中调用 `call_ai_vision_ocr_service` 时，将 `custom_ai_vision_base_url` 作为参数传递。

*   **代码演示:**

    ```python
    # src/core/ocr.py
    
    # ... (其他 import)
    from src.shared import constants # 确保导入常量
    from src.interfaces.vision_interface import call_ai_vision_ocr_service # 确保导入
    
    logger = logging.getLogger("CoreOCR")
    
    def recognize_text_in_bubbles(image_pil, bubble_coords, source_language='japan', ocr_engine='auto',
                                  baidu_api_key=None, baidu_secret_key=None, baidu_version="standard",
                                  ai_vision_provider=None, ai_vision_api_key=None,
                                  ai_vision_model_name=None, ai_vision_ocr_prompt=None,
                                  # VVVVVV 新增参数 VVVVVV
                                  custom_ai_vision_base_url=None,
                                  # ^^^^^^ 结束新增 ^^^^^^
                                  use_json_format_for_ai_vision=False,
                                  rpd_limit_ai_vision: int = constants.DEFAULT_RPD_AI_VISION_OCR):
        # ... (函数开头的代码，包括 ocr_engine_type 的确定) ...
    
        if ocr_engine_type == 'AIVision':
            if all([ai_vision_provider, ai_vision_api_key, ai_vision_model_name]):
                # VVVVVV 新增检查：自定义服务商必须有 Base URL VVVVVV
                if ai_vision_provider == constants.CUSTOM_AI_VISION_PROVIDER_ID and not custom_ai_vision_base_url:
                    logger.error("使用自定义AI视觉OCR时，缺少Base URL (custom_ai_vision_base_url)，OCR步骤跳过。")
                    return [""] * len(bubble_coords) # 返回与气泡数量匹配的空字符串列表
                # ^^^^^^ 结束新增检查 ^^^^^^
    
                logger.info(f"开始使用 AI视觉OCR ({ai_vision_provider}/{ai_vision_model_name}, RPD: {rpd_limit_ai_vision if rpd_limit_ai_vision > 0 else '无'}, BaseURL: {custom_ai_vision_base_url if custom_ai_vision_base_url else '服务商默认'}) 识别 {len(bubble_coords)} 个气泡...")
                # ... (获取 current_ai_vision_ocr_prompt 的逻辑) ...
                try:
                    for i, (x1, y1, x2, y2) in enumerate(bubble_coords):
                        try:
                            # ... (裁剪图片 bubble_img_pil) ...
                            # ... (RPD 限制 _enforce_rpd_limit) ...
    
                            logger.info(f"处理气泡 {i} (AI视觉OCR)...")
                            ocr_result_raw = call_ai_vision_ocr_service(
                                bubble_img_pil,
                                provider=ai_vision_provider,
                                api_key=ai_vision_api_key,
                                model_name=ai_vision_model_name,
                                prompt=current_ai_vision_ocr_prompt,
                                # VVVVVV 新增传递 custom_base_url VVVVVV
                                custom_base_url=custom_ai_vision_base_url
                                # ^^^^^^ 结束新增 ^^^^^^
                            )
                            # ... (处理 ocr_result_raw 和 recognized_texts[i] 的逻辑) ...
                        except Exception as e_bubble: # 使用不同的变量名避免与外部的 e 冲突
                            logger.error(f"处理气泡 {i} (AI视觉OCR) 时出错: {e_bubble}", exc_info=True)
                            recognized_texts[i] = ""
                    logger.info("AI视觉OCR 识别完成。")
                except Exception as e_loop: # 循环外的异常
                    logger.error(f"AI视觉OCR 处理循环中发生错误: {e_loop}", exc_info=True)
            else:
                logger.error("使用 AI视觉OCR 时，缺少必要参数(provider/api_key/model_name)，OCR步骤跳过。")
        # ... (其他 OCR 引擎的处理逻辑：BaiduOCR, PaddleOCR, MangaOCR) ...
        else:
             logger.error(f"未知的 OCR 引擎类型: {ocr_engine_type}")
    
        return recognized_texts
    
    # ... (文件底部的测试代码) ...
    ```

---

**4.3. 更新 AI 视觉接口 (`src/interfaces/vision_interface.py`)**

*   **文件路径:** `src/interfaces/vision_interface.py`
*   **修改内容:**
    1.  修改 `call_ai_vision_ocr_service` 函数签名，增加 `custom_base_url=None` 参数。
    2.  创建一个新的私有辅助函数 `_call_generic_openai_vision_api`。这个函数将包含之前用于火山引擎和 Gemini 的通用 `openai` 库调用逻辑，但其 `base_url` 将作为一个参数 `base_url_to_use` 传入。
    3.  修改 `call_ai_vision_ocr_service` 内部：
        *   当 `provider` 是 `'volcano'` 时，调用 `_call_generic_openai_vision_api` 并传入火山引擎的固定 Base URL。
        *   当 `provider` 是 `'gemini'` 时，调用 `_call_generic_openai_vision_api` 并传入 Gemini 的固定 Base URL。
        *   当 `provider` 是 `constants.CUSTOM_AI_VISION_PROVIDER_ID` 时，检查 `custom_base_url` 是否提供。如果提供了，则调用 `_call_generic_openai_vision_api` 并传入这个 `custom_base_url`。如果未提供，记录错误并返回空。
    4.  `call_siliconflow_vision_api` 函数保持不变，因为它不使用 `openai` 库。
    5.  修改 `test_ai_vision_ocr` 函数签名，增加 `custom_base_url=None` 参数，并在调用 `call_ai_vision_ocr_service` 时传递它。

*   **代码演示:**

    ```python
    # src/interfaces/vision_interface.py
    
    import logging
    import base64
    import requests
    import json
    import time
    # from io import BytesIO # 如果直接处理字节流而非PIL Image
    from PIL import Image
    from openai import OpenAI # 确保导入
    
    from src.shared import constants # 确保导入常量
    from src.shared.image_helpers import image_to_base64
    
    logger = logging.getLogger("VisionInterface")
    
    # VVVVVV 新增：通用的 OpenAI 兼容视觉 API 调用函数 VVVVVV
    def _call_generic_openai_vision_api(image_base64, api_key, model_name, prompt, base_url_to_use, service_friendly_name, start_time):
        """
        通用的 OpenAI 兼容视觉 API 调用函数。
        """
        logger.info(f"开始调用 {service_friendly_name} 视觉API (通过 OpenAI SDK)，模型: {model_name}, BaseURL: {base_url_to_use}")
        try:
            if not base_url_to_use: # 增加对 base_url_to_use 的检查
                logger.error(f"调用 {service_friendly_name} 失败：未提供 Base URL。")
                return ""
    
            client = OpenAI(api_key=api_key, base_url=base_url_to_use) # 使用传入的 base_url_to_use
    
            payload_messages = [ # payload 结构保持一致
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt},
                        {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{image_base64}"}}
                    ]
                }
            ]
            # (可选) 调试日志，与 Gemini 部分类似
            # debug_payload = { "model": model_name, "messages": [...] }
            # logger.debug(f"{service_friendly_name} API 请求体 (无图): {json.dumps(debug_payload, ensure_ascii=False)}")
    
            response = client.chat.completions.create(
                model=model_name,
                messages=payload_messages,
                timeout=60
            )
    
            if response and response.choices and len(response.choices) > 0:
                content = response.choices[0].message.content
                elapsed_time = time.time() - start_time
                logger.info(f"{service_friendly_name} 视觉OCR识别成功，耗时: {elapsed_time:.2f}秒")
                logger.info(f"识别结果 (前100字符): {content[:100]}")
                return content.strip()
            else:
                logger.error(f"{service_friendly_name} 响应格式异常或无有效结果, 响应: {response}")
                return ""
        except Exception as e:
            logger.error(f"调用 {service_friendly_name} 视觉API ({base_url_to_use}) 时发生异常: {e}", exc_info=True)
            # 记录更详细的错误响应 (如果可用)
            if hasattr(e, 'response') and e.response is not None:
                try:
                    error_detail = e.response.json()
                    logger.error(f"{service_friendly_name} API 错误详情: {error_detail}")
                except json.JSONDecodeError:
                    logger.error(f"{service_friendly_name} API 原始错误响应 (状态码 {e.response.status_code}): {e.response.text}")
            return ""
    # ^^^^^^ 结束新增辅助函数 ^^^^^^


    def call_ai_vision_ocr_service(image_pil, provider='siliconflow', api_key=None, model_name=None, prompt=None,
                                   # VVVVVV 新增 custom_base_url 参数 VVVVVV
                                   custom_base_url=None):
                                   # ^^^^^^ 结束新增 ^^^^^^
        if not image_pil:
            logger.error("未提供有效图像")
            return ""
        if not api_key:
            logger.error(f"未提供 {provider} 的API密钥")
            return ""
        if not model_name:
            logger.error(f"未提供 {provider} 的模型名称")
            return ""
        if not prompt:
            prompt = constants.DEFAULT_AI_VISION_OCR_PROMPT
            logger.info(f"使用默认AI视觉OCR提示词")
    
        start_time = time.time()
        try:
            image_base64 = image_to_base64(image_pil)
        except Exception as e:
            logger.error(f"图像转Base64失败: {e}")
            return ""
    
        try:
            provider_lower = provider.lower()
            if provider_lower == 'siliconflow':
                return call_siliconflow_vision_api(image_base64, api_key, model_name, prompt, start_time)
            elif provider_lower == 'volcano':
                # VVVVVV 修改为调用通用函数 VVVVVV
                return _call_generic_openai_vision_api(image_base64, api_key, model_name, prompt,
                                                       "https://ark.cn-beijing.volces.com/api/v3",
                                                       "火山引擎", start_time)
                # ^^^^^^ 结束修改 ^^^^^^
            elif provider_lower == 'gemini':
                # VVVVVV 修改为调用通用函数 VVVVVV
                return _call_generic_openai_vision_api(image_base64, api_key, model_name, prompt,
                                                       "https://generativelanguage.googleapis.com/v1beta/openai/",
                                                       "Gemini Vision", start_time)
                # ^^^^^^ 结束修改 ^^^^^^
            # VVVVVV 新增对自定义服务商的处理 VVVVVV
            elif provider_lower == constants.CUSTOM_AI_VISION_PROVIDER_ID: # 使用后端常量
                if not custom_base_url: # 检查 custom_base_url
                    logger.error(f"未提供自定义AI视觉OCR服务的Base URL (provider: {provider})")
                    return ""
                return _call_generic_openai_vision_api(image_base64, api_key, model_name, prompt,
                                                       custom_base_url, # <<< 使用传入的自定义 Base URL
                                                       "自定义OpenAI兼容视觉服务", start_time)
            # ^^^^^^ 结束新增 ^^^^^^
            else:
                logger.error(f"不支持的AI视觉OCR服务提供商: {provider}")
                return ""
        except Exception as e: # 捕获 call_xxx 函数可能抛出的其他未预料错误
            logger.error(f"调用AI视觉OCR服务 ({provider}) 时发生顶层异常: {e}", exc_info=True)
            return ""
    
    # call_siliconflow_vision_api 函数保持不变 (因为它不使用 openai SDK)
    def call_siliconflow_vision_api(image_base64, api_key, model_name, prompt, start_time):
        # ... (此函数内容不变) ...
        logger.info(f"开始调用SiliconFlow视觉API进行OCR识别，模型: {model_name}")
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {api_key}'
        }
        payload = {
            "model": model_name,
            "messages": [ { "role": "user", "content": [ {"type": "text", "text": prompt}, {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{image_base64}"}} ] } ]
        }
        try:
            response = requests.post( "https://api.siliconflow.cn/v1/chat/completions", headers=headers, json=payload, timeout=60)
            if response.status_code == 200:
                result = response.json()
                if 'choices' in result and len(result['choices']) > 0:
                    content = result['choices'][0]['message']['content']
                    elapsed_time = time.time() - start_time
                    logger.info(f"SiliconFlow视觉OCR识别成功，耗时: {elapsed_time:.2f}秒")
                    logger.info(f"识别结果: {content}")
                    return content.strip()
                else: logger.error(f"SiliconFlow响应格式异常: {result}"); return ""
            else: logger.error(f"SiliconFlow API请求失败: HTTP {response.status_code}, {response.text}"); return ""
        except requests.exceptions.Timeout: logger.error("SiliconFlow API请求超时"); return ""
        except requests.exceptions.ConnectionError: logger.error("SiliconFlow API连接错误"); return ""
        except Exception as e: logger.error(f"调用SiliconFlow视觉API时发生异常: {e}"); return ""


    # call_volcano_vision_api 和 call_gemini_vision_api 可以被移除了，
    # 因为它们的功能已经被 _call_generic_openai_vision_api 和 call_ai_vision_ocr_service 中的逻辑覆盖。
    # 或者，保留它们作为快捷方式，内部调用 _call_generic_openai_vision_api，如下：
    
    # def call_volcano_vision_api(image_base64, api_key, model_name, prompt, start_time):
    #     return _call_generic_openai_vision_api(image_base64, api_key, model_name, prompt,
    #                                            "https://ark.cn-beijing.volces.com/api/v3",
    #                                            "火山引擎", start_time)
    
    # def call_gemini_vision_api(image_base64, api_key, model_name, prompt, start_time):
    #     return _call_generic_openai_vision_api(image_base64, api_key, model_name, prompt,
    #                                            "https://generativelanguage.googleapis.com/v1beta/openai/",
    #                                            "Gemini Vision", start_time)


    # 更新 test_ai_vision_ocr 函数签名和内部调用
    def test_ai_vision_ocr(image_path, provider, api_key, model_name, prompt=None,
                           # VVVVVV 新增 custom_base_url 参数 VVVVVV
                           custom_base_url=None):
                           # ^^^^^^ 结束新增 ^^^^^^
        try:
            # 加载图片
            with Image.open(image_path) as img:
                # 调用OCR服务
                result = call_ai_vision_ocr_service( # 调用更新后的主服务函数
                    img,
                    provider,
                    api_key,
                    model_name,
                    prompt,
                    custom_base_url=custom_base_url # <<< 传递自定义 Base URL
                )
    
                if result:
                    logger.info(f"测试成功，服务商: {provider}, 模型: {model_name}, 识别结果 (部分): {result[:100]}...")
                    return True, f"识别成功 (部分结果: {result[:50]}...)" # 返回更简洁的消息给前端
                else:
                    logger.error(f"测试失败，服务商: {provider}, 模型: {model_name}, 未返回有效识别结果")
                    return False, "OCR识别失败，未返回有效结果"
        except FileNotFoundError:
            logger.error(f"测试图片未找到: {image_path}")
            return False, f"测试图片未找到: {image_path}"
        except Exception as e:
            logger.error(f"测试过程中发生错误 (服务商: {provider}, 模型: {model_name}): {e}", exc_info=True)
            return False, f"测试出错: {str(e)}"
    
    # ... (文件底部的测试代码，如果需要，也应更新以测试自定义服务) ...
    ```

